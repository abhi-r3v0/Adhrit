{"version":3,"file":"router.d.ts","sources":["router.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v10.0.14\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { AfterContentInit } from '@angular/core';\r\nimport { ChangeDetectorRef } from '@angular/core';\r\nimport { Compiler } from '@angular/core';\r\nimport { ComponentFactoryResolver } from '@angular/core';\r\nimport { ComponentRef } from '@angular/core';\r\nimport { ElementRef } from '@angular/core';\r\nimport { EventEmitter } from '@angular/core';\r\nimport { HashLocationStrategy } from '@angular/common';\r\nimport { InjectionToken } from '@angular/core';\r\nimport { Injector } from '@angular/core';\r\nimport { Location } from '@angular/common';\r\nimport { LocationStrategy } from '@angular/common';\r\nimport { ModuleWithProviders } from '@angular/core';\r\nimport { NgModuleFactory } from '@angular/core';\r\nimport { NgModuleFactoryLoader } from '@angular/core';\r\nimport { NgProbeToken } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { OnChanges } from '@angular/core';\r\nimport { OnDestroy } from '@angular/core';\r\nimport { OnInit } from '@angular/core';\r\nimport { PathLocationStrategy } from '@angular/common';\r\nimport { PlatformLocation } from '@angular/common';\r\nimport { Provider } from '@angular/core';\r\nimport { QueryList } from '@angular/core';\r\nimport { Renderer2 } from '@angular/core';\r\nimport { SimpleChanges } from '@angular/core';\r\nimport { Type } from '@angular/core';\r\nimport { Version } from '@angular/core';\r\nimport { ViewContainerRef } from '@angular/core';\r\nimport { ViewportScroller } from '@angular/common';\r\n\r\n/**\r\n * Provides access to information about a route associated with a component\r\n * that is loaded in an outlet.\r\n * Use to traverse the `RouterState` tree and extract information from nodes.\r\n *\r\n * The following example shows how to construct a component using information from a\r\n * currently activated route.\r\n *\r\n * {@example router/activated-route/module.ts region=\"activated-route\"\r\n *     header=\"activated-route.component.ts\"}\r\n *\r\n * @see [Getting route information](guide/router#getting-route-information)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ActivatedRoute {\r\n    /** An observable of the URL segments matched by this route. */\r\n    url: Observable<UrlSegment[]>;\r\n    /** An observable of the matrix parameters scoped to this route. */\r\n    params: Observable<Params>;\r\n    /** An observable of the query parameters shared by all the routes. */\r\n    queryParams: Observable<Params>;\r\n    /** An observable of the URL fragment shared by all the routes. */\r\n    fragment: Observable<string>;\r\n    /** An observable of the static and resolved data of this route. */\r\n    data: Observable<Data>;\r\n    /** The outlet name of the route, a constant. */\r\n    outlet: string;\r\n    /** The component of the route, a constant. */\r\n    component: Type<any> | string | null;\r\n    /** The current snapshot of this route */\r\n    snapshot: ActivatedRouteSnapshot;\r\n    /** The configuration used to match this route. */\r\n    get routeConfig(): Route | null;\r\n    /** The root of the router state. */\r\n    get root(): ActivatedRoute;\r\n    /** The parent of this route in the router state tree. */\r\n    get parent(): ActivatedRoute | null;\r\n    /** The first child of this route in the router state tree. */\r\n    get firstChild(): ActivatedRoute | null;\r\n    /** The children of this route in the router state tree. */\r\n    get children(): ActivatedRoute[];\r\n    /** The path from the root of the router state tree to this route. */\r\n    get pathFromRoot(): ActivatedRoute[];\r\n    /**\r\n     * An Observable that contains a map of the required and optional parameters\r\n     * specific to the route.\r\n     * The map supports retrieving single and multiple values from the same parameter.\r\n     */\r\n    get paramMap(): Observable<ParamMap>;\r\n    /**\r\n     * An Observable that contains a map of the query parameters available to all routes.\r\n     * The map supports retrieving single and multiple values from the query parameter.\r\n     */\r\n    get queryParamMap(): Observable<ParamMap>;\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Contains the information about a route associated with a component loaded in an\r\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\r\n * traverse the router state tree.\r\n *\r\n * The following example initializes a component with route information extracted\r\n * from the snapshot of the root node at the time of creation.\r\n *\r\n * ```\r\n * @Component({templateUrl:'./my-component.html'})\r\n * class MyComponent {\r\n *   constructor(route: ActivatedRoute) {\r\n *     const id: string = route.snapshot.params.id;\r\n *     const url: string = route.snapshot.url.join('');\r\n *     const user = route.snapshot.data.user;\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ActivatedRouteSnapshot {\r\n    /** The URL segments matched by this route */\r\n    url: UrlSegment[];\r\n    /** The matrix parameters scoped to this route */\r\n    params: Params;\r\n    /** The query parameters shared by all the routes */\r\n    queryParams: Params;\r\n    /** The URL fragment shared by all the routes */\r\n    fragment: string;\r\n    /** The static and resolved data of this route */\r\n    data: Data;\r\n    /** The outlet name of the route */\r\n    outlet: string;\r\n    /** The component of the route */\r\n    component: Type<any> | string | null;\r\n    /** The configuration used to match this route **/\r\n    readonly routeConfig: Route | null;\r\n    /** The root of the router state */\r\n    get root(): ActivatedRouteSnapshot;\r\n    /** The parent of this route in the router state tree */\r\n    get parent(): ActivatedRouteSnapshot | null;\r\n    /** The first child of this route in the router state tree */\r\n    get firstChild(): ActivatedRouteSnapshot | null;\r\n    /** The children of this route in the router state tree */\r\n    get children(): ActivatedRouteSnapshot[];\r\n    /** The path from the root of the router state tree to this route */\r\n    get pathFromRoot(): ActivatedRouteSnapshot[];\r\n    get paramMap(): ParamMap;\r\n    get queryParamMap(): ParamMap;\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * An event triggered at the end of the activation part\r\n * of the Resolve phase of routing.\r\n * @see `ActivationStart`\r\n * @see `ResolveStart`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ActivationEnd {\r\n    /** @docsNotRequired */\r\n    snapshot: ActivatedRouteSnapshot;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    snapshot: ActivatedRouteSnapshot);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * An event triggered at the start of the activation part\r\n * of the Resolve phase of routing.\r\n * @see `ActivationEnd`\r\n * @see `ResolveStart`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ActivationStart {\r\n    /** @docsNotRequired */\r\n    snapshot: ActivatedRouteSnapshot;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    snapshot: ActivatedRouteSnapshot);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Interface that a class can implement to be a guard deciding if a route can be activated.\r\n * If all guards return `true`, navigation continues. If any guard returns `false`,\r\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\r\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\r\n *\r\n * The following example implements a `CanActivate` function that checks whether the\r\n * current user has permission to activate the requested route.\r\n *\r\n * ```\r\n * class UserToken {}\r\n * class Permissions {\r\n *   canActivate(user: UserToken, id: string): boolean {\r\n *     return true;\r\n *   }\r\n * }\r\n *\r\n * @Injectable()\r\n * class CanActivateTeam implements CanActivate {\r\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\r\n *\r\n *   canActivate(\r\n *     route: ActivatedRouteSnapshot,\r\n *     state: RouterStateSnapshot\r\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\r\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Here, the defined guard function is provided as part of the `Route` object\r\n * in the router configuration:\r\n *\r\n * ```\r\n * @NgModule({\r\n *   imports: [\r\n *     RouterModule.forRoot([\r\n *       {\r\n *         path: 'team/:id',\r\n *         component: TeamComponent,\r\n *         canActivate: [CanActivateTeam]\r\n *       }\r\n *     ])\r\n *   ],\r\n *   providers: [CanActivateTeam, UserToken, Permissions]\r\n * })\r\n * class AppModule {}\r\n * ```\r\n *\r\n * You can alternatively provide an in-line function with the `canActivate` signature:\r\n *\r\n * ```\r\n * @NgModule({\r\n *   imports: [\r\n *     RouterModule.forRoot([\r\n *       {\r\n *         path: 'team/:id',\r\n *         component: TeamComponent,\r\n *         canActivate: ['canActivateTeam']\r\n *       }\r\n *     ])\r\n *   ],\r\n *   providers: [\r\n *     {\r\n *       provide: 'canActivateTeam',\r\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true\r\n *     }\r\n *   ]\r\n * })\r\n * class AppModule {}\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface CanActivate {\r\n    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Interface that a class can implement to be a guard deciding if a child route can be activated.\r\n * If all guards return `true`, navigation continues. If any guard returns `false`,\r\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\r\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\r\n *\r\n * The following example implements a `CanActivateChild` function that checks whether the\r\n * current user has permission to activate the requested child route.\r\n *\r\n * ```\r\n * class UserToken {}\r\n * class Permissions {\r\n *   canActivate(user: UserToken, id: string): boolean {\r\n *     return true;\r\n *   }\r\n * }\r\n *\r\n * @Injectable()\r\n * class CanActivateTeam implements CanActivateChild {\r\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\r\n *\r\n *   canActivateChild(\r\n *     route: ActivatedRouteSnapshot,\r\n *     state: RouterStateSnapshot\r\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\r\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Here, the defined guard function is provided as part of the `Route` object\r\n * in the router configuration:\r\n *\r\n * ```\r\n * @NgModule({\r\n *   imports: [\r\n *     RouterModule.forRoot([\r\n *       {\r\n *         path: 'root',\r\n *         canActivateChild: [CanActivateTeam],\r\n *         children: [\r\n *           {\r\n *              path: 'team/:id',\r\n *              component: TeamComponent\r\n *           }\r\n *         ]\r\n *       }\r\n *     ])\r\n *   ],\r\n *   providers: [CanActivateTeam, UserToken, Permissions]\r\n * })\r\n * class AppModule {}\r\n * ```\r\n *\r\n * You can alternatively provide an in-line function with the `canActivateChild` signature:\r\n *\r\n * ```\r\n * @NgModule({\r\n *   imports: [\r\n *     RouterModule.forRoot([\r\n *       {\r\n *         path: 'root',\r\n *         canActivateChild: ['canActivateTeam'],\r\n *         children: [\r\n *           {\r\n *             path: 'team/:id',\r\n *             component: TeamComponent\r\n *           }\r\n *         ]\r\n *       }\r\n *     ])\r\n *   ],\r\n *   providers: [\r\n *     {\r\n *       provide: 'canActivateTeam',\r\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true\r\n *     }\r\n *   ]\r\n * })\r\n * class AppModule {}\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface CanActivateChild {\r\n    canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Interface that a class can implement to be a guard deciding if a route can be deactivated.\r\n * If all guards return `true`, navigation continues. If any guard returns `false`,\r\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\r\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\r\n *\r\n * The following example implements a `CanDeactivate` function that checks whether the\r\n * current user has permission to deactivate the requested route.\r\n *\r\n * ```\r\n * class UserToken {}\r\n * class Permissions {\r\n *   canDeactivate(user: UserToken, id: string): boolean {\r\n *     return true;\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Here, the defined guard function is provided as part of the `Route` object\r\n * in the router configuration:\r\n *\r\n * ```\r\n *\r\n * @Injectable()\r\n * class CanDeactivateTeam implements CanDeactivate<TeamComponent> {\r\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\r\n *\r\n *   canDeactivate(\r\n *     component: TeamComponent,\r\n *     currentRoute: ActivatedRouteSnapshot,\r\n *     currentState: RouterStateSnapshot,\r\n *     nextState: RouterStateSnapshot\r\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\r\n *     return this.permissions.canDeactivate(this.currentUser, route.params.id);\r\n *   }\r\n * }\r\n *\r\n * @NgModule({\r\n *   imports: [\r\n *     RouterModule.forRoot([\r\n *       {\r\n *         path: 'team/:id',\r\n *         component: TeamComponent,\r\n *         canDeactivate: [CanDeactivateTeam]\r\n *       }\r\n *     ])\r\n *   ],\r\n *   providers: [CanDeactivateTeam, UserToken, Permissions]\r\n * })\r\n * class AppModule {}\r\n * ```\r\n *\r\n * You can alternatively provide an in-line function with the `canDeactivate` signature:\r\n *\r\n * ```\r\n * @NgModule({\r\n *   imports: [\r\n *     RouterModule.forRoot([\r\n *       {\r\n *         path: 'team/:id',\r\n *         component: TeamComponent,\r\n *         canDeactivate: ['canDeactivateTeam']\r\n *       }\r\n *     ])\r\n *   ],\r\n *   providers: [\r\n *     {\r\n *       provide: 'canDeactivateTeam',\r\n *       useValue: (component: TeamComponent, currentRoute: ActivatedRouteSnapshot, currentState:\r\n * RouterStateSnapshot, nextState: RouterStateSnapshot) => true\r\n *     }\r\n *   ]\r\n * })\r\n * class AppModule {}\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface CanDeactivate<T> {\r\n    canDeactivate(component: T, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState?: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Interface that a class can implement to be a guard deciding if children can be loaded.\r\n * If all guards return `true`, navigation continues. If any guard returns `false`,\r\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\r\n * is cancelled and a new navigation starts to the `UrlTree` returned from the guard.\r\n *\r\n * The following example implements a `CanLoad` function that decides whether the\r\n * current user has permission to load requested child routes.\r\n *\r\n *\r\n * ```\r\n * class UserToken {}\r\n * class Permissions {\r\n *   canLoadChildren(user: UserToken, id: string, segments: UrlSegment[]): boolean {\r\n *     return true;\r\n *   }\r\n * }\r\n *\r\n * @Injectable()\r\n * class CanLoadTeamSection implements CanLoad {\r\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\r\n *\r\n *   canLoad(route: Route, segments: UrlSegment[]): Observable<boolean>|Promise<boolean>|boolean {\r\n *     return this.permissions.canLoadChildren(this.currentUser, route, segments);\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Here, the defined guard function is provided as part of the `Route` object\r\n * in the router configuration:\r\n *\r\n * ```\r\n *\r\n * @NgModule({\r\n *   imports: [\r\n *     RouterModule.forRoot([\r\n *       {\r\n *         path: 'team/:id',\r\n *         component: TeamComponent,\r\n *         loadChildren: 'team.js',\r\n *         canLoad: [CanLoadTeamSection]\r\n *       }\r\n *     ])\r\n *   ],\r\n *   providers: [CanLoadTeamSection, UserToken, Permissions]\r\n * })\r\n * class AppModule {}\r\n * ```\r\n *\r\n * You can alternatively provide an in-line function with the `canLoad` signature:\r\n *\r\n * ```\r\n * @NgModule({\r\n *   imports: [\r\n *     RouterModule.forRoot([\r\n *       {\r\n *         path: 'team/:id',\r\n *         component: TeamComponent,\r\n *         loadChildren: 'team.js',\r\n *         canLoad: ['canLoadTeamSection']\r\n *       }\r\n *     ])\r\n *   ],\r\n *   providers: [\r\n *     {\r\n *       provide: 'canLoadTeamSection',\r\n *       useValue: (route: Route, segments: UrlSegment[]) => true\r\n *     }\r\n *   ]\r\n * })\r\n * class AppModule {}\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface CanLoad {\r\n    canLoad(route: Route, segments: UrlSegment[]): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\r\n}\r\n\r\n/**\r\n * An event triggered at the end of the child-activation part\r\n * of the Resolve phase of routing.\r\n * @see `ChildActivationStart`\r\n * @see `ResolveStart`\r\n * @publicApi\r\n */\r\nexport declare class ChildActivationEnd {\r\n    /** @docsNotRequired */\r\n    snapshot: ActivatedRouteSnapshot;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    snapshot: ActivatedRouteSnapshot);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * An event triggered at the start of the child-activation\r\n * part of the Resolve phase of routing.\r\n * @see  `ChildActivationEnd`\r\n * @see `ResolveStart`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ChildActivationStart {\r\n    /** @docsNotRequired */\r\n    snapshot: ActivatedRouteSnapshot;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    snapshot: ActivatedRouteSnapshot);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * Store contextual information about the children (= nested) `RouterOutlet`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ChildrenOutletContexts {\r\n    private contexts;\r\n    /** Called when a `RouterOutlet` directive is instantiated */\r\n    onChildOutletCreated(childName: string, outlet: RouterOutlet): void;\r\n    /**\r\n     * Called when a `RouterOutlet` directive is destroyed.\r\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\r\n     * re-created later.\r\n     */\r\n    onChildOutletDestroyed(childName: string): void;\r\n    /**\r\n     * Called when the corresponding route is deactivated during navigation.\r\n     * Because the component get destroyed, all children outlet are destroyed.\r\n     */\r\n    onOutletDeactivated(): Map<string, OutletContext>;\r\n    onOutletReAttached(contexts: Map<string, OutletContext>): void;\r\n    getOrCreateContext(childName: string): OutletContext;\r\n    getContext(childName: string): OutletContext | null;\r\n}\r\n\r\n/**\r\n * Converts a `Params` instance to a `ParamMap`.\r\n * @param params The instance to convert.\r\n * @returns The new map instance.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function convertToParamMap(params: Params): ParamMap;\r\n\r\n/**\r\n *\r\n * Represents static data associated with a particular route.\r\n *\r\n * @see `Route#data`\r\n *\r\n * @publicApi\r\n */\r\nexport declare type Data = {\r\n    [name: string]: any;\r\n};\r\n\r\n/**\r\n * @description\r\n *\r\n * A default implementation of the `UrlSerializer`.\r\n *\r\n * Example URLs:\r\n *\r\n * ```\r\n * /inbox/33(popup:compose)\r\n * /inbox/33;open=true/messages/44\r\n * ```\r\n *\r\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\r\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\r\n * specify route specific parameters.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class DefaultUrlSerializer implements UrlSerializer {\r\n    /** Parses a url into a `UrlTree` */\r\n    parse(url: string): UrlTree;\r\n    /** Converts a `UrlTree` into a url */\r\n    serialize(tree: UrlTree): string;\r\n}\r\n\r\n/**\r\n * A string of the form `path/to/file#exportName` that acts as a URL for a set of routes to load.\r\n *\r\n * @see `loadChildrenCallback`\r\n * @publicApi\r\n * @deprecated The `string` form of `loadChildren` is deprecated in favor of the\r\n * `LoadChildrenCallback` function which uses the ES dynamic `import()` expression.\r\n * This offers a more natural and standards-based mechanism to dynamically\r\n * load an ES module at runtime.\r\n */\r\nexport declare type DeprecatedLoadChildren = string;\r\n\r\n/**\r\n * @description\r\n *\r\n * Represents the detached route tree.\r\n *\r\n * This is an opaque value the router will give to a custom route reuse strategy\r\n * to store and retrieve later on.\r\n *\r\n * @publicApi\r\n */\r\nexport declare type DetachedRouteHandle = {};\r\n\r\n/**\r\n * Error handler that is invoked when a navigation error occurs.\r\n *\r\n * If the handler returns a value, the navigation Promise is resolved with this value.\r\n * If the handler throws an exception, the navigation Promise is rejected with\r\n * the exception.\r\n *\r\n * @publicApi\r\n */\r\ndeclare type ErrorHandler = (error: any) => any;\r\n\r\n/**\r\n * Router events that allow you to track the lifecycle of the router.\r\n *\r\n * The events occur in the following sequence:\r\n *\r\n * * [NavigationStart](api/router/NavigationStart): Navigation starts.\r\n * * [RouteConfigLoadStart](api/router/RouteConfigLoadStart): Before\r\n * the router [lazy loads](/guide/router#lazy-loading) a route configuration.\r\n * * [RouteConfigLoadEnd](api/router/RouteConfigLoadEnd): After a route has been lazy loaded.\r\n * * [RoutesRecognized](api/router/RoutesRecognized): When the router parses the URL\r\n * and the routes are recognized.\r\n * * [GuardsCheckStart](api/router/GuardsCheckStart): When the router begins the *guards*\r\n * phase of routing.\r\n * * [ChildActivationStart](api/router/ChildActivationStart): When the router\r\n * begins activating a route's children.\r\n * * [ActivationStart](api/router/ActivationStart): When the router begins activating a route.\r\n * * [GuardsCheckEnd](api/router/GuardsCheckEnd): When the router finishes the *guards*\r\n * phase of routing successfully.\r\n * * [ResolveStart](api/router/ResolveStart): When the router begins the *resolve*\r\n * phase of routing.\r\n * * [ResolveEnd](api/router/ResolveEnd): When the router finishes the *resolve*\r\n * phase of routing successfuly.\r\n * * [ChildActivationEnd](api/router/ChildActivationEnd): When the router finishes\r\n * activating a route's children.\r\n * * [ActivationEnd](api/router/ActivationStart): When the router finishes activating a route.\r\n * * [NavigationEnd](api/router/NavigationEnd): When navigation ends successfully.\r\n * * [NavigationCancel](api/router/NavigationCancel): When navigation is canceled.\r\n * * [NavigationError](api/router/NavigationError): When navigation fails\r\n * due to an unexpected error.\r\n * * [Scroll](api/router/Scroll): When the user scrolls.\r\n *\r\n * @publicApi\r\n */\r\nexport declare type Event = RouterEvent | RouteConfigLoadStart | RouteConfigLoadEnd | ChildActivationStart | ChildActivationEnd | ActivationStart | ActivationEnd | Scroll;\r\n\r\n/**\r\n * A set of configuration options for a router module, provided in the\r\n * `forRoot()` method.\r\n *\r\n * @see `forRoot()`\r\n *\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface ExtraOptions {\r\n    /**\r\n     * When true, log all internal navigation events to the console.\r\n     * Use for debugging.\r\n     */\r\n    enableTracing?: boolean;\r\n    /**\r\n     * When true, enable the location strategy that uses the URL fragment\r\n     * instead of the history API.\r\n     */\r\n    useHash?: boolean;\r\n    /**\r\n     * One of `enabled` or `disabled`.\r\n     * When set to `enabled`, the initial navigation starts before the root component is created.\r\n     * The bootstrap is blocked until the initial navigation is complete. This value is required for\r\n     * [server-side rendering](guide/universal) to work.\r\n     * When set to `disabled`, the initial navigation is not performed.\r\n     * The location listener is set up before the root component gets created.\r\n     * Use if there is a reason to have more control over when the router\r\n     * starts its initial navigation due to some complex initialization logic.\r\n     *\r\n     * Legacy values are deprecated since v4 and should not be used for new applications:\r\n     *\r\n     * * `legacy_enabled` - Default for compatibility.\r\n     * The initial navigation starts after the root component has been created,\r\n     * but the bootstrap is not blocked until the initial navigation is complete.\r\n     * * `legacy_disabled` - The initial navigation is not performed.\r\n     * The location listener is set up after the root component gets created.\r\n     * * `true` - same as `legacy_enabled`.\r\n     * * `false` - same as `legacy_disabled`.\r\n     */\r\n    initialNavigation?: InitialNavigation;\r\n    /**\r\n     * A custom error handler for failed navigations.\r\n     * If the handler returns a value, the navigation Promise is resolved with this value.\r\n     * If the handler throws an exception, the navigation Promise is rejected with the exception.\r\n     *\r\n     */\r\n    errorHandler?: ErrorHandler;\r\n    /**\r\n     * Configures a preloading strategy.\r\n     * One of `PreloadAllModules` or `NoPreloading` (the default).\r\n     */\r\n    preloadingStrategy?: any;\r\n    /**\r\n     * Define what the router should do if it receives a navigation request to the current URL.\r\n     * Default is `ignore`, which causes the router ignores the navigation.\r\n     * This can disable features such as a \"refresh\" button.\r\n     * Use this option to configure the behavior when navigating to the\r\n     * current URL. Default is 'ignore'.\r\n     */\r\n    onSameUrlNavigation?: 'reload' | 'ignore';\r\n    /**\r\n     * Configures if the scroll position needs to be restored when navigating back.\r\n     *\r\n     * * 'disabled'- (Default) Does nothing. Scroll position is maintained on navigation.\r\n     * * 'top'- Sets the scroll position to x = 0, y = 0 on all navigation.\r\n     * * 'enabled'- Restores the previous scroll position on backward navigation, else sets the\r\n     * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\r\n     * navigation). This option will be the default in the future.\r\n     *\r\n     * You can implement custom scroll restoration behavior by adapting the enabled behavior as\r\n     * in the following example.\r\n     *\r\n     * ```typescript\r\n     * class AppModule {\r\n     *   constructor(router: Router, viewportScroller: ViewportScroller) {\r\n     *     router.events.pipe(\r\n     *       filter((e: Event): e is Scroll => e instanceof Scroll)\r\n     *     ).subscribe(e => {\r\n     *       if (e.position) {\r\n     *         // backward navigation\r\n     *         viewportScroller.scrollToPosition(e.position);\r\n     *       } else if (e.anchor) {\r\n     *         // anchor navigation\r\n     *         viewportScroller.scrollToAnchor(e.anchor);\r\n     *       } else {\r\n     *         // forward navigation\r\n     *         viewportScroller.scrollToPosition([0, 0]);\r\n     *       }\r\n     *     });\r\n     *   }\r\n     * }\r\n     * ```\r\n     */\r\n    scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\r\n    /**\r\n     * When set to 'enabled', scrolls to the anchor element when the URL has a fragment.\r\n     * Anchor scrolling is disabled by default.\r\n     *\r\n     * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\r\n     * that we stored or scroll to the top.\r\n     */\r\n    anchorScrolling?: 'disabled' | 'enabled';\r\n    /**\r\n     * Configures the scroll offset the router will use when scrolling to an element.\r\n     *\r\n     * When given a tuple with x and y position value,\r\n     * the router uses that offset each time it scrolls.\r\n     * When given a function, the router invokes the function every time\r\n     * it restores scroll position.\r\n     */\r\n    scrollOffset?: [number, number] | (() => [number, number]);\r\n    /**\r\n     * Defines how the router merges parameters, data, and resolved data from parent to child\r\n     * routes. By default ('emptyOnly'), inherits parent parameters only for\r\n     * path-less or component-less routes.\r\n     * Set to 'always' to enable unconditional inheritance of parent parameters.\r\n     */\r\n    paramsInheritanceStrategy?: 'emptyOnly' | 'always';\r\n    /**\r\n     * A custom handler for malformed URI errors. The handler is invoked when `encodedURI` contains\r\n     * invalid character sequences.\r\n     * The default implementation is to redirect to the root URL, dropping\r\n     * any path or parameter information. The function takes three parameters:\r\n     *\r\n     * - `'URIError'` - Error thrown when parsing a bad URL.\r\n     * - `'UrlSerializer'` - UrlSerializer that’s configured with the router.\r\n     * - `'url'` -  The malformed URL that caused the URIError\r\n     * */\r\n    malformedUriErrorHandler?: (error: URIError, urlSerializer: UrlSerializer, url: string) => UrlTree;\r\n    /**\r\n     * Defines when the router updates the browser URL. By default ('deferred'),\r\n     * update after successful navigation.\r\n     * Set to 'eager' if prefer to update the URL at the beginning of navigation.\r\n     * Updating the URL early allows you to handle a failure of navigation by\r\n     * showing an error message with the URL that failed.\r\n     */\r\n    urlUpdateStrategy?: 'deferred' | 'eager';\r\n    /**\r\n     * Enables a bug fix that corrects relative link resolution in components with empty paths.\r\n     * Example:\r\n     *\r\n     * ```\r\n     * const routes = [\r\n     *   {\r\n     *     path: '',\r\n     *     component: ContainerComponent,\r\n     *     children: [\r\n     *       { path: 'a', component: AComponent },\r\n     *       { path: 'b', component: BComponent },\r\n     *     ]\r\n     *   }\r\n     * ];\r\n     * ```\r\n     *\r\n     * From the `ContainerComponent`, this will not work:\r\n     *\r\n     * `<a [routerLink]=\"['./a']\">Link to A</a>`\r\n     *\r\n     * However, this will work:\r\n     *\r\n     * `<a [routerLink]=\"['../a']\">Link to A</a>`\r\n     *\r\n     * In other words, you're required to use `../` rather than `./`. This is currently the default\r\n     * behavior. Setting this option to `corrected` enables the fix.\r\n     */\r\n    relativeLinkResolution?: 'legacy' | 'corrected';\r\n}\r\n\r\n/**\r\n * An event triggered at the end of the Guard phase of routing.\r\n *\r\n * @see `GuardsCheckStart`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class GuardsCheckEnd extends RouterEvent {\r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string;\r\n    /** @docsNotRequired */\r\n    state: RouterStateSnapshot;\r\n    /** @docsNotRequired */\r\n    shouldActivate: boolean;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id: number, \r\n    /** @docsNotRequired */\r\n    url: string, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string, \r\n    /** @docsNotRequired */\r\n    state: RouterStateSnapshot, \r\n    /** @docsNotRequired */\r\n    shouldActivate: boolean);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * An event triggered at the start of the Guard phase of routing.\r\n *\r\n * @see `GuardsCheckEnd`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class GuardsCheckStart extends RouterEvent {\r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string;\r\n    /** @docsNotRequired */\r\n    state: RouterStateSnapshot;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id: number, \r\n    /** @docsNotRequired */\r\n    url: string, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string, \r\n    /** @docsNotRequired */\r\n    state: RouterStateSnapshot);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * Allowed values in an `ExtraOptions` object that configure\r\n * when the router performs the initial navigation operation.\r\n *\r\n * * 'enabled' - The initial navigation starts before the root component is created.\r\n * The bootstrap is blocked until the initial navigation is complete. This value is required\r\n * for [server-side rendering](guide/universal) to work.\r\n * * 'disabled' - The initial navigation is not performed. The location listener is set up before\r\n * the root component gets created. Use if there is a reason to have\r\n * more control over when the router starts its initial navigation due to some complex\r\n * initialization logic.\r\n *\r\n * The following values have been [deprecated](guide/releases#deprecation-practices) since v4,\r\n * and should not be used for new applications.\r\n *\r\n * * 'legacy_enabled'- (Default, for compatibility.) The initial navigation starts after the root\r\n * component has been created. The bootstrap is not blocked until the initial navigation is\r\n * complete.\r\n * * 'legacy_disabled'- The initial navigation is not performed. The location listener is set up\r\n * after the root component gets created.\r\n * * `true` - same as 'legacy_enabled'.\r\n * * `false` - same as 'legacy_disabled'.\r\n *\r\n * The 'legacy_enabled' and 'legacy_disabled' should not be used for new applications.\r\n *\r\n * @see `forRoot()`\r\n *\r\n * @publicApi\r\n */\r\nexport declare type InitialNavigation = true | false | 'enabled' | 'disabled' | 'legacy_enabled' | 'legacy_disabled';\r\n\r\n/**\r\n *\r\n * A function that returns a set of routes to load.\r\n *\r\n * The string form of `LoadChildren` is deprecated (see `DeprecatedLoadChildren`). The function\r\n * form (`LoadChildrenCallback`) should be used instead.\r\n *\r\n * @see `loadChildrenCallback`\r\n * @publicApi\r\n */\r\nexport declare type LoadChildren = LoadChildrenCallback | DeprecatedLoadChildren;\r\n\r\n/**\r\n *\r\n * A function that is called to resolve a collection of lazy-loaded routes.\r\n * Must be an arrow function of the following form:\r\n * `() => import('...').then(mod => mod.MODULE)`\r\n *\r\n * For example:\r\n *\r\n * ```\r\n * [{\r\n *   path: 'lazy',\r\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\r\n * }];\r\n * ```\r\n *\r\n * @see [Route.loadChildren](api/router/Route#loadChildren)\r\n * @publicApi\r\n */\r\nexport declare type LoadChildrenCallback = () => Type<any> | NgModuleFactory<any> | Observable<Type<any>> | Promise<NgModuleFactory<any> | Type<any> | any>;\r\n\r\n/**\r\n * Information about a navigation operation.\r\n * Retrieve the most recent navigation object with the\r\n * [Router.getCurrentNavigation() method](api/router/Router#getcurrentnavigation) .\r\n *\r\n * * *id* : The unique identifier of the current navigation.\r\n * * *initialUrl* : The target URL passed into the `Router#navigateByUrl()` call before navigation.\r\n * This is the value before the router has parsed or applied redirects to it.\r\n * * *extractedUrl* : The initial target URL after being parsed with `UrlSerializer.extract()`.\r\n * * *finalUrl* : The extracted URL after redirects have been applied.\r\n * This URL may not be available immediately, therefore this property can be `undefined`.\r\n * It is guaranteed to be set after the `RoutesRecognized` event fires.\r\n * * *trigger* : Identifies how this navigation was triggered.\r\n * -- 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\r\n * -- 'popstate'--Triggered by a popstate event.\r\n * -- 'hashchange'--Triggered by a hashchange event.\r\n * * *extras* : A `NavigationExtras` options object that controlled the strategy used for this\r\n * navigation.\r\n * * *previousNavigation* : The previously successful `Navigation` object. Only one previous\r\n * navigation is available, therefore this previous `Navigation` object has a `null` value for its\r\n * own `previousNavigation`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare type Navigation = {\r\n    /**\r\n     * The unique identifier of the current navigation.\r\n     */\r\n    id: number;\r\n    /**\r\n     * The target URL passed into the `Router#navigateByUrl()` call before navigation. This is\r\n     * the value before the router has parsed or applied redirects to it.\r\n     */\r\n    initialUrl: string | UrlTree;\r\n    /**\r\n     * The initial target URL after being parsed with `UrlSerializer.extract()`.\r\n     */\r\n    extractedUrl: UrlTree;\r\n    /**\r\n     * The extracted URL after redirects have been applied.\r\n     * This URL may not be available immediately, therefore this property can be `undefined`.\r\n     * It is guaranteed to be set after the `RoutesRecognized` event fires.\r\n     */\r\n    finalUrl?: UrlTree;\r\n    /**\r\n     * Identifies how this navigation was triggered.\r\n     *\r\n     * * 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\r\n     * * 'popstate'--Triggered by a popstate event.\r\n     * * 'hashchange'--Triggered by a hashchange event.\r\n     */\r\n    trigger: 'imperative' | 'popstate' | 'hashchange';\r\n    /**\r\n     * Options that controlled the strategy used for this navigation.\r\n     * See `NavigationExtras`.\r\n     */\r\n    extras: NavigationExtras;\r\n    /**\r\n     * The previously successful `Navigation` object. Only one previous navigation\r\n     * is available, therefore this previous `Navigation` object has a `null` value\r\n     * for its own `previousNavigation`.\r\n     */\r\n    previousNavigation: Navigation | null;\r\n};\r\n\r\n/**\r\n * An event triggered when a navigation is canceled, directly or indirectly.\r\n * This can happen when a route guard\r\n * returns `false` or initiates a redirect by returning a `UrlTree`.\r\n *\r\n * @see `NavigationStart`\r\n * @see `NavigationEnd`\r\n * @see `NavigationError`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class NavigationCancel extends RouterEvent {\r\n    /** @docsNotRequired */\r\n    reason: string;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id: number, \r\n    /** @docsNotRequired */\r\n    url: string, \r\n    /** @docsNotRequired */\r\n    reason: string);\r\n    /** @docsNotRequired */\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * An event triggered when a navigation ends successfully.\r\n *\r\n * @see `NavigationStart`\r\n * @see `NavigationCancel`\r\n * @see `NavigationError`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class NavigationEnd extends RouterEvent {\r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id: number, \r\n    /** @docsNotRequired */\r\n    url: string, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string);\r\n    /** @docsNotRequired */\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * An event triggered when a navigation fails due to an unexpected error.\r\n *\r\n * @see `NavigationStart`\r\n * @see `NavigationEnd`\r\n * @see `NavigationCancel`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class NavigationError extends RouterEvent {\r\n    /** @docsNotRequired */\r\n    error: any;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id: number, \r\n    /** @docsNotRequired */\r\n    url: string, \r\n    /** @docsNotRequired */\r\n    error: any);\r\n    /** @docsNotRequired */\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Options that modify the `Router` navigation strategy.\r\n * Supply an object containing any of these properties to a `Router` navigation function to\r\n * control how the target URL should be constructed or interpreted.\r\n *\r\n * @see [Router.navigate() method](api/router/Router#navigate)\r\n * @see [Router.navigateByUrl() method](api/router/Router#navigatebyurl)\r\n * @see [Router.createUrlTree() method](api/router/Router#createurltree)\r\n * @see [Routing and Navigation guide](guide/router)\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface NavigationExtras {\r\n    /**\r\n     * Specifies a root URI to use for relative navigation.\r\n     *\r\n     * For example, consider the following route configuration where the parent route\r\n     * has two children.\r\n     *\r\n     * ```\r\n     * [{\r\n     *   path: 'parent',\r\n     *   component: ParentComponent,\r\n     *   children: [{\r\n     *     path: 'list',\r\n     *     component: ListComponent\r\n     *   },{\r\n     *     path: 'child',\r\n     *     component: ChildComponent\r\n     *   }]\r\n     * }]\r\n     * ```\r\n     *\r\n     * The following `go()` function navigates to the `list` route by\r\n     * interpreting the destination URI as relative to the activated `child`  route\r\n     *\r\n     * ```\r\n     *  @Component({...})\r\n     *  class ChildComponent {\r\n     *    constructor(private router: Router, private route: ActivatedRoute) {}\r\n     *\r\n     *    go() {\r\n     *      this.router.navigate(['../list'], { relativeTo: this.route });\r\n     *    }\r\n     *  }\r\n     * ```\r\n     */\r\n    relativeTo?: ActivatedRoute | null;\r\n    /**\r\n     * Sets query parameters to the URL.\r\n     *\r\n     * ```\r\n     * // Navigate to /results?page=1\r\n     * this.router.navigate(['/results'], { queryParams: { page: 1 } });\r\n     * ```\r\n     */\r\n    queryParams?: Params | null;\r\n    /**\r\n     * Sets the hash fragment for the URL.\r\n     *\r\n     * ```\r\n     * // Navigate to /results#top\r\n     * this.router.navigate(['/results'], { fragment: 'top' });\r\n     * ```\r\n     */\r\n    fragment?: string;\r\n    /**\r\n     * **DEPRECATED**: Use `queryParamsHandling: \"preserve\"` instead to preserve\r\n     * query parameters for the next navigation.\r\n     *\r\n     * @deprecated since v4\r\n     */\r\n    preserveQueryParams?: boolean;\r\n    /**\r\n     * How to handle query parameters in the router link for the next navigation.\r\n     * One of:\r\n     * * `preserve` : Preserve current parameters.\r\n     * * `merge` : Merge new with current parameters.\r\n     *\r\n     * The \"preserve\" option discards any new query params:\r\n     * ```\r\n     * // from /view1?page=1 to/view2?page=1\r\n     * this.router.navigate(['/view2'], { queryParams: { page: 2 },  queryParamsHandling: \"preserve\"\r\n     * });\r\n     * ```\r\n     * The \"merge\" option appends new query params to the params from the current URL:\r\n     * ```\r\n     * // from /view1?page=1 to/view2?page=1&otherKey=2\r\n     * this.router.navigate(['/view2'], { queryParams: { otherKey: 2 },  queryParamsHandling: \"merge\"\r\n     * });\r\n     * ```\r\n     * In case of a key collision between current parameters and those in the `queryParams` object,\r\n     * the new value is used.\r\n     *\r\n     */\r\n    queryParamsHandling?: QueryParamsHandling | null;\r\n    /**\r\n     * When true, preserves the URL fragment for the next navigation\r\n     *\r\n     * ```\r\n     * // Preserve fragment from /results#top to /view#top\r\n     * this.router.navigate(['/view'], { preserveFragment: true });\r\n     * ```\r\n     */\r\n    preserveFragment?: boolean;\r\n    /**\r\n     * When true, navigates without pushing a new state into history.\r\n     *\r\n     * ```\r\n     * // Navigate silently to /view\r\n     * this.router.navigate(['/view'], { skipLocationChange: true });\r\n     * ```\r\n     */\r\n    skipLocationChange?: boolean;\r\n    /**\r\n     * When true, navigates while replacing the current state in history.\r\n     *\r\n     * ```\r\n     * // Navigate to /view\r\n     * this.router.navigate(['/view'], { replaceUrl: true });\r\n     * ```\r\n     */\r\n    replaceUrl?: boolean;\r\n    /**\r\n     * Developer-defined state that can be passed to any navigation.\r\n     * Access this value through the `Navigation.extras` object\r\n     * returned from the [Router.getCurrentNavigation()\r\n     * method](api/router/Router#getcurrentnavigation) while a navigation is executing.\r\n     *\r\n     * After a navigation completes, the router writes an object containing this\r\n     * value together with a `navigationId` to `history.state`.\r\n     * The value is written when `location.go()` or `location.replaceState()`\r\n     * is called before activating this route.\r\n     *\r\n     * Note that `history.state` does not pass an object equality test because\r\n     * the router adds the `navigationId` on each navigation.\r\n     *\r\n     */\r\n    state?: {\r\n        [k: string]: any;\r\n    };\r\n}\r\n\r\n/**\r\n * An event triggered when a navigation starts.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class NavigationStart extends RouterEvent {\r\n    /**\r\n     * Identifies the call or event that triggered the navigation.\r\n     * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\r\n     *\r\n     * @see `NavigationEnd`\r\n     * @see `NavigationCancel`\r\n     * @see `NavigationError`\r\n     */\r\n    navigationTrigger?: 'imperative' | 'popstate' | 'hashchange';\r\n    /**\r\n     * The navigation state that was previously supplied to the `pushState` call,\r\n     * when the navigation is triggered by a `popstate` event. Otherwise null.\r\n     *\r\n     * The state object is defined by `NavigationExtras`, and contains any\r\n     * developer-defined state value, as well as a unique ID that\r\n     * the router assigns to every router transition/navigation.\r\n     *\r\n     * From the perspective of the router, the router never \"goes back\".\r\n     * When the user clicks on the back button in the browser,\r\n     * a new navigation ID is created.\r\n     *\r\n     * Use the ID in this previous-state object to differentiate between a newly created\r\n     * state and one returned to by a `popstate` event, so that you can restore some\r\n     * remembered state, such as scroll position.\r\n     *\r\n     */\r\n    restoredState?: {\r\n        [k: string]: any;\r\n        navigationId: number;\r\n    } | null;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id: number, \r\n    /** @docsNotRequired */\r\n    url: string, \r\n    /** @docsNotRequired */\r\n    navigationTrigger?: 'imperative' | 'popstate' | 'hashchange', \r\n    /** @docsNotRequired */\r\n    restoredState?: {\r\n        [k: string]: any;\r\n        navigationId: number;\r\n    } | null);\r\n    /** @docsNotRequired */\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Provides a preloading strategy that does not preload any modules.\r\n *\r\n * This strategy is enabled by default.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class NoPreloading implements PreloadingStrategy {\r\n    preload(route: Route, fn: () => Observable<any>): Observable<any>;\r\n}\r\n\r\n/**\r\n * Store contextual information about a `RouterOutlet`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class OutletContext {\r\n    outlet: RouterOutlet | null;\r\n    route: ActivatedRoute | null;\r\n    resolver: ComponentFactoryResolver | null;\r\n    children: ChildrenOutletContexts;\r\n    attachRef: ComponentRef<any> | null;\r\n}\r\n\r\n/**\r\n * A map that provides access to the required and optional parameters\r\n * specific to a route.\r\n * The map supports retrieving a single value with `get()`\r\n * or multiple values with `getAll()`.\r\n *\r\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface ParamMap {\r\n    /**\r\n     * Reports whether the map contains a given parameter.\r\n     * @param name The parameter name.\r\n     * @returns True if the map contains the given parameter, false otherwise.\r\n     */\r\n    has(name: string): boolean;\r\n    /**\r\n     * Retrieves a single value for a parameter.\r\n     * @param name The parameter name.\r\n     * @return The parameter's single value,\r\n     * or the first value if the parameter has multiple values,\r\n     * or `null` when there is no such parameter.\r\n     */\r\n    get(name: string): string | null;\r\n    /**\r\n     * Retrieves multiple values for a parameter.\r\n     * @param name The parameter name.\r\n     * @return An array containing one or more values,\r\n     * or an empty array if there is no such parameter.\r\n     *\r\n     */\r\n    getAll(name: string): string[];\r\n    /** Names of the parameters in the map. */\r\n    readonly keys: string[];\r\n}\r\n\r\n/**\r\n * A collection of matrix and query URL parameters.\r\n * @see `convertToParamMap()`\r\n * @see `ParamMap`\r\n *\r\n * @publicApi\r\n */\r\nexport declare type Params = {\r\n    [key: string]: any;\r\n};\r\n\r\n/**\r\n * @description\r\n *\r\n * Provides a preloading strategy that preloads all modules as quickly as possible.\r\n *\r\n * ```\r\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare class PreloadAllModules implements PreloadingStrategy {\r\n    preload(route: Route, fn: () => Observable<any>): Observable<any>;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Provides a preloading strategy.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class PreloadingStrategy {\r\n    abstract preload(route: Route, fn: () => Observable<any>): Observable<any>;\r\n}\r\n\r\n/**\r\n * The primary routing outlet.\r\n *\r\n * @publicApi\r\n */\r\nexport declare const PRIMARY_OUTLET = \"primary\";\r\n\r\n/**\r\n * Registers a [DI provider](guide/glossary#provider) for a set of routes.\r\n * @param routes The route configuration to provide.\r\n *\r\n * @usageNotes\r\n *\r\n * ```\r\n * @NgModule({\r\n *   imports: [RouterModule.forChild(ROUTES)],\r\n *   providers: [provideRoutes(EXTRA_ROUTES)]\r\n * })\r\n * class MyNgModule {}\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare function provideRoutes(routes: Routes): any;\r\n\r\n/**\r\n *\r\n * How to handle query parameters in a router link.\r\n * One of:\r\n * - `merge` : Merge new with current parameters.\r\n * - `preserve` : Preserve current parameters.\r\n *\r\n * @see `NavigationExtras#queryParamsHandling`\r\n * @see `RouterLink`\r\n * @publicApi\r\n */\r\nexport declare type QueryParamsHandling = 'merge' | 'preserve' | '';\r\n\r\n/**\r\n * @description\r\n *\r\n * Interface that classes can implement to be a data provider.\r\n * A data provider class can be used with the router to resolve data during navigation.\r\n * The interface defines a `resolve()` method that is invoked when the navigation starts.\r\n * The router waits for the data to be resolved before the route is finally activated.\r\n *\r\n * The following example implements a `resolve()` method that retrieves the data\r\n * needed to activate the requested route.\r\n *\r\n * ```\r\n * @Injectable({ providedIn: 'root' })\r\n * export class HeroResolver implements Resolve<Hero> {\r\n *   constructor(private service: HeroService) {}\r\n *\r\n *   resolve(\r\n *     route: ActivatedRouteSnapshot,\r\n *     state: RouterStateSnapshot\r\n *   ): Observable<any>|Promise<any>|any {\r\n *     return this.service.getHero(route.paramMap.get('id'));\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Here, the defined `resolve()` function is provided as part of the `Route` object\r\n * in the router configuration:\r\n *\r\n * ```\r\n\r\n * @NgModule({\r\n *   imports: [\r\n *     RouterModule.forRoot([\r\n *       {\r\n *         path: 'detail/:id',\r\n *         component: HeroDetailComponent,\r\n *         resolve: {\r\n *           hero: HeroResolver\r\n *         }\r\n *       }\r\n *     ])\r\n *   ],\r\n *   exports: [RouterModule]\r\n * })\r\n * export class AppRoutingModule {}\r\n * ```\r\n *\r\n * You can alternatively provide an in-line function with the `resolve()` signature:\r\n *\r\n * ```\r\n * export const myHero: Hero = {\r\n *   // ...\r\n * }\r\n *\r\n * @NgModule({\r\n *   imports: [\r\n *     RouterModule.forRoot([\r\n *       {\r\n *         path: 'detail/:id',\r\n *         component: HeroComponent,\r\n *         resolve: {\r\n *           hero: 'heroResolver'\r\n *         }\r\n *       }\r\n *     ])\r\n *   ],\r\n *   providers: [\r\n *     {\r\n *       provide: 'heroResolver',\r\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => myHero\r\n *     }\r\n *   ]\r\n * })\r\n * export class AppModule {}\r\n * ```\r\n *\r\n * @usageNotes\r\n *\r\n * When both guard and resolvers are specified, the resolvers are not executed until\r\n * all guards have run and succeeded.\r\n * For example, consider the following route configuration:\r\n *\r\n * ```\r\n * {\r\n *  path: 'base'\r\n *  canActivate: [BaseGuard],\r\n *  resolve: {data: BaseDataResolver}\r\n *  children: [\r\n *   {\r\n *     path: 'child',\r\n *     guards: [ChildGuard],\r\n *     component: ChildComponent,\r\n *     resolve: {childData: ChildDataResolver}\r\n *    }\r\n *  ]\r\n * }\r\n * ```\r\n * The order of execution is: BaseGuard, ChildGuard, BaseDataResolver, ChildDataResolver.\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface Resolve<T> {\r\n    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<T> | Promise<T> | T;\r\n}\r\n\r\n/**\r\n *\r\n * Represents the resolved data associated with a particular route.\r\n *\r\n * @see `Route#resolve`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare type ResolveData = {\r\n    [name: string]: any;\r\n};\r\n\r\n/**\r\n * An event triggered at the end of the Resolve phase of routing.\r\n * @see `ResolveStart`.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ResolveEnd extends RouterEvent {\r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string;\r\n    /** @docsNotRequired */\r\n    state: RouterStateSnapshot;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id: number, \r\n    /** @docsNotRequired */\r\n    url: string, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string, \r\n    /** @docsNotRequired */\r\n    state: RouterStateSnapshot);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * An event triggered at the the start of the Resolve phase of routing.\r\n *\r\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\r\n * In future, may change to only run when there are things to be resolved.\r\n *\r\n * @see `ResolveEnd`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ResolveStart extends RouterEvent {\r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string;\r\n    /** @docsNotRequired */\r\n    state: RouterStateSnapshot;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id: number, \r\n    /** @docsNotRequired */\r\n    url: string, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string, \r\n    /** @docsNotRequired */\r\n    state: RouterStateSnapshot);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * A configuration object that defines a single route.\r\n * A set of routes are collected in a `Routes` array to define a `Router` configuration.\r\n * The router attempts to match segments of a given URL against each route,\r\n * using the configuration options defined in this object.\r\n *\r\n * Supports static, parameterized, redirect, and wildcard routes, as well as\r\n * custom route data and resolve methods.\r\n *\r\n * For detailed usage information, see the [Routing Guide](guide/router).\r\n *\r\n * @usageNotes\r\n *\r\n * ### Simple Configuration\r\n *\r\n * The following route specifies that when navigating to, for example,\r\n * `/team/11/user/bob`, the router creates the 'Team' component\r\n * with the 'User' child component in it.\r\n *\r\n * ```\r\n * [{\r\n *   path: 'team/:id',\r\n  *  component: Team,\r\n *   children: [{\r\n *     path: 'user/:name',\r\n *     component: User\r\n *   }]\r\n * }]\r\n * ```\r\n *\r\n * ### Multiple Outlets\r\n *\r\n * The following route creates sibling components with multiple outlets.\r\n * When navigating to `/team/11(aux:chat/jim)`, the router creates the 'Team' component next to\r\n * the 'Chat' component. The 'Chat' component is placed into the 'aux' outlet.\r\n *\r\n * ```\r\n * [{\r\n *   path: 'team/:id',\r\n *   component: Team\r\n * }, {\r\n *   path: 'chat/:user',\r\n *   component: Chat\r\n *   outlet: 'aux'\r\n * }]\r\n * ```\r\n *\r\n * ### Wild Cards\r\n *\r\n * The following route uses wild-card notation to specify a component\r\n * that is always instantiated regardless of where you navigate to.\r\n *\r\n * ```\r\n * [{\r\n *   path: '**',\r\n *   component: WildcardComponent\r\n * }]\r\n * ```\r\n *\r\n * ### Redirects\r\n *\r\n * The following route uses the `redirectTo` property to ignore a segment of\r\n * a given URL when looking for a child path.\r\n *\r\n * When navigating to '/team/11/legacy/user/jim', the router changes the URL segment\r\n * '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates\r\n * the Team component with the User child component in it.\r\n *\r\n * ```\r\n * [{\r\n *   path: 'team/:id',\r\n *   component: Team,\r\n *   children: [{\r\n *     path: 'legacy/user/:name',\r\n *     redirectTo: 'user/:name'\r\n *   }, {\r\n *     path: 'user/:name',\r\n *     component: User\r\n *   }]\r\n * }]\r\n * ```\r\n *\r\n * The redirect path can be relative, as shown in this example, or absolute.\r\n * If we change the `redirectTo` value in the example to the absolute URL segment '/user/:name',\r\n * the result URL is also absolute, '/user/jim'.\r\n\r\n * ### Empty Path\r\n *\r\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\r\n * any URL segments.\r\n *\r\n * In the following configuration, when navigating to\r\n * `/team/11`, the router instantiates the 'AllUsers' component.\r\n *\r\n * ```\r\n * [{\r\n *   path: 'team/:id',\r\n *   component: Team,\r\n *   children: [{\r\n *     path: '',\r\n *     component: AllUsers\r\n *   }, {\r\n *     path: 'user/:name',\r\n *     component: User\r\n *   }]\r\n * }]\r\n * ```\r\n *\r\n * Empty-path routes can have children. In the following example, when navigating\r\n * to `/team/11/user/jim`, the router instantiates the wrapper component with\r\n * the user component in it.\r\n *\r\n * Note that an empty path route inherits its parent's parameters and data.\r\n *\r\n * ```\r\n * [{\r\n *   path: 'team/:id',\r\n *   component: Team,\r\n *   children: [{\r\n *     path: '',\r\n *     component: WrapperCmp,\r\n *     children: [{\r\n *       path: 'user/:name',\r\n *       component: User\r\n *     }]\r\n *   }]\r\n * }]\r\n * ```\r\n *\r\n * ### Matching Strategy\r\n *\r\n * The default path-match strategy is 'prefix', which means that the router\r\n * checks URL elements from the left to see if the URL matches a specified path.\r\n * For example, '/team/11/user' matches 'team/:id'.\r\n *\r\n * ```\r\n * [{\r\n *   path: '',\r\n *   pathMatch: 'prefix', //default\r\n *   redirectTo: 'main'\r\n * }, {\r\n *   path: 'main',\r\n *   component: Main\r\n * }]\r\n * ```\r\n *\r\n * You can specify the path-match strategy 'full' to make sure that the path\r\n * covers the whole unconsumed URL. It is important to do this when redirecting\r\n * empty-path routes. Otherwise, because an empty path is a prefix of any URL,\r\n * the router would apply the redirect even when navigating to the redirect destination,\r\n * creating an endless loop.\r\n *\r\n * In the following example, supplying the 'full' `pathMatch` strategy ensures\r\n * that the router applies the redirect if and only if navigating to '/'.\r\n *\r\n * ```\r\n * [{\r\n *   path: '',\r\n *   pathMatch: 'full',\r\n *   redirectTo: 'main'\r\n * }, {\r\n *   path: 'main',\r\n *   component: Main\r\n * }]\r\n * ```\r\n *\r\n * ### Componentless Routes\r\n *\r\n * You can share parameters between sibling components.\r\n * For example, suppose that two sibling components should go next to each other,\r\n * and both of them require an ID parameter. You can accomplish this using a route\r\n * that does not specify a component at the top level.\r\n *\r\n * In the following example, 'MainChild' and 'AuxChild' are siblings.\r\n * When navigating to 'parent/10/(a//aux:b)', the route instantiates\r\n * the main child and aux child components next to each other.\r\n * For this to work, the application component must have the primary and aux outlets defined.\r\n *\r\n * ```\r\n * [{\r\n *    path: 'parent/:id',\r\n *    children: [\r\n *      { path: 'a', component: MainChild },\r\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\r\n *    ]\r\n * }]\r\n * ```\r\n *\r\n * The router merges the parameters, data, and resolve of the componentless\r\n * parent into the parameters, data, and resolve of the children.\r\n *\r\n * This is especially useful when child components are defined\r\n * with an empty path string, as in the following example.\r\n * With this configuration, navigating to '/parent/10' creates\r\n * the main child and aux components.\r\n *\r\n * ```\r\n * [{\r\n *    path: 'parent/:id',\r\n *    children: [\r\n *      { path: '', component: MainChild },\r\n *      { path: '', component: AuxChild, outlet: 'aux' }\r\n *    ]\r\n * }]\r\n * ```\r\n *\r\n * ### Lazy Loading\r\n *\r\n * Lazy loading speeds up application load time by splitting the application\r\n * into multiple bundles and loading them on demand.\r\n * To use lazy loading, provide the `loadChildren` property in the `Route` object,\r\n * instead of the `children` property.\r\n *\r\n * Given the following example route, the router will lazy load\r\n * the associated module on demand using the browser native import system.\r\n *\r\n * ```\r\n * [{\r\n *   path: 'lazy',\r\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\r\n * }];\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface Route {\r\n    /**\r\n     * The path to match against. Cannot be used together with a custom `matcher` function.\r\n     * A URL string that uses router matching notation.\r\n     * Can be a wild card (`**`) that matches any URL (see Usage Notes below).\r\n     * Default is \"/\" (the root path).\r\n     *\r\n     */\r\n    path?: string;\r\n    /**\r\n     * The path-matching strategy, one of 'prefix' or 'full'.\r\n     * Default is 'prefix'.\r\n     *\r\n     * By default, the router checks URL elements from the left to see if the URL\r\n     * matches a given  path, and stops when there is a match. For example,\r\n     * '/team/11/user' matches 'team/:id'.\r\n     *\r\n     * The path-match strategy 'full' matches against the entire URL.\r\n     * It is important to do this when redirecting empty-path routes.\r\n     * Otherwise, because an empty path is a prefix of any URL,\r\n     * the router would apply the redirect even when navigating\r\n     * to the redirect destination, creating an endless loop.\r\n     *\r\n     */\r\n    pathMatch?: string;\r\n    /**\r\n     * A custom URL-matching function. Cannot be used together with `path`.\r\n     */\r\n    matcher?: UrlMatcher;\r\n    /**\r\n     * The component to instantiate when the path matches.\r\n     * Can be empty if child routes specify components.\r\n     */\r\n    component?: Type<any>;\r\n    /**\r\n     * A URL to redirect to when the path matches.\r\n     * Absolute if the URL begins with a slash (/), otherwise relative to the path URL.\r\n     * When not present, router does not redirect.\r\n     */\r\n    redirectTo?: string;\r\n    /**\r\n     * Name of a `RouterOutlet` object where the component can be placed\r\n     * when the path matches.\r\n     */\r\n    outlet?: string;\r\n    /**\r\n     * An array of dependency-injection tokens used to look up `CanActivate()`\r\n     * handlers, in order to determine if the current user is allowed to\r\n     * activate the component. By default, any user can activate.\r\n     */\r\n    canActivate?: any[];\r\n    /**\r\n     * An array of DI tokens used to look up `CanActivateChild()` handlers,\r\n     * in order to determine if the current user is allowed to activate\r\n     * a child of the component. By default, any user can activate a child.\r\n     */\r\n    canActivateChild?: any[];\r\n    /**\r\n     * An array of DI tokens used to look up `CanDeactivate()`\r\n     * handlers, in order to determine if the current user is allowed to\r\n     * deactivate the component. By default, any user can deactivate.\r\n     *\r\n     */\r\n    canDeactivate?: any[];\r\n    /**\r\n     * An array of DI tokens used to look up `CanLoad()`\r\n     * handlers, in order to determine if the current user is allowed to\r\n     * load the component. By default, any user can load.\r\n     */\r\n    canLoad?: any[];\r\n    /**\r\n     * Additional developer-defined data provided to the component via\r\n     * `ActivatedRoute`. By default, no additional data is passed.\r\n     */\r\n    data?: Data;\r\n    /**\r\n     * A map of DI tokens used to look up data resolvers. See `Resolve`.\r\n     */\r\n    resolve?: ResolveData;\r\n    /**\r\n     * An array of child `Route` objects that specifies a nested route\r\n     * configuration.\r\n     */\r\n    children?: Routes;\r\n    /**\r\n     * An object specifying lazy-loaded child routes.\r\n     */\r\n    loadChildren?: LoadChildren;\r\n    /**\r\n     * Defines when guards and resolvers will be run. One of\r\n     * - `paramsOrQueryParamsChange` : Run when query parameters change.\r\n     * - `always` : Run on every execution.\r\n     * By default, guards and resolvers run only when the matrix\r\n     * parameters of the route change.\r\n     */\r\n    runGuardsAndResolvers?: RunGuardsAndResolvers;\r\n}\r\n\r\n/**\r\n * An event triggered when a route has been lazy loaded.\r\n *\r\n * @see `RouteConfigLoadStart`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RouteConfigLoadEnd {\r\n    /** @docsNotRequired */\r\n    route: Route;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    route: Route);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * An event triggered before lazy loading a route configuration.\r\n *\r\n * @see `RouteConfigLoadEnd`\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RouteConfigLoadStart {\r\n    /** @docsNotRequired */\r\n    route: Route;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    route: Route);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * A service that provides navigation among views and URL manipulation capabilities.\r\n *\r\n * @see `Route`.\r\n * @see [Routing and Navigation Guide](guide/router).\r\n *\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\r\nexport declare class Router {\r\n    private rootComponentType;\r\n    private urlSerializer;\r\n    private rootContexts;\r\n    private location;\r\n    config: Routes;\r\n    private currentUrlTree;\r\n    private rawUrlTree;\r\n    private browserUrlTree;\r\n    private readonly transitions;\r\n    private navigations;\r\n    private lastSuccessfulNavigation;\r\n    private currentNavigation;\r\n    private locationSubscription;\r\n    private navigationId;\r\n    private configLoader;\r\n    private ngModule;\r\n    private console;\r\n    private isNgZoneEnabled;\r\n    /**\r\n     * An event stream for routing events in this NgModule.\r\n     */\r\n    readonly events: Observable<Event>;\r\n    /**\r\n     * The current state of routing in this NgModule.\r\n     */\r\n    readonly routerState: RouterState;\r\n    /**\r\n     * A handler for navigation errors in this NgModule.\r\n     */\r\n    errorHandler: ErrorHandler;\r\n    /**\r\n     * A handler for errors thrown by `Router.parseUrl(url)`\r\n     * when `url` contains an invalid character.\r\n     * The most common case is a `%` sign\r\n     * that's not encoded and is not part of a percent encoded sequence.\r\n     */\r\n    malformedUriErrorHandler: (error: URIError, urlSerializer: UrlSerializer, url: string) => UrlTree;\r\n    /**\r\n     * True if at least one navigation event has occurred,\r\n     * false otherwise.\r\n     */\r\n    navigated: boolean;\r\n    private lastSuccessfulId;\r\n    /**\r\n     * A strategy for extracting and merging URLs.\r\n     * Used for AngularJS to Angular migrations.\r\n     */\r\n    urlHandlingStrategy: UrlHandlingStrategy;\r\n    /**\r\n     * A strategy for re-using routes.\r\n     */\r\n    routeReuseStrategy: RouteReuseStrategy;\r\n    /**\r\n     * How to handle a navigation request to the current URL. One of:\r\n     * - `'ignore'` :  The router ignores the request.\r\n     * - `'reload'` : The router reloads the URL. Use to implement a \"refresh\" feature.\r\n     */\r\n    onSameUrlNavigation: 'reload' | 'ignore';\r\n    /**\r\n     * How to merge parameters, data, and resolved data from parent to child\r\n     * routes. One of:\r\n     *\r\n     * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data\r\n     * for path-less or component-less routes.\r\n     * - `'always'` : Inherit parent parameters, data, and resolved data\r\n     * for all child routes.\r\n     */\r\n    paramsInheritanceStrategy: 'emptyOnly' | 'always';\r\n    /**\r\n     * Determines when the router updates the browser URL.\r\n     * By default (`\"deferred\"`), updates the browser URL after navigation has finished.\r\n     * Set to `'eager'` to update the browser URL at the beginning of navigation.\r\n     * You can choose to update early so that, if navigation fails,\r\n     * you can show an error message with the URL that failed.\r\n     */\r\n    urlUpdateStrategy: 'deferred' | 'eager';\r\n    /**\r\n     * Enables a bug fix that corrects relative link resolution in components with empty paths.\r\n     * @see `RouterModule`\r\n     */\r\n    relativeLinkResolution: 'legacy' | 'corrected';\r\n    /**\r\n     * Creates the router service.\r\n     */\r\n    constructor(rootComponentType: Type<any> | null, urlSerializer: UrlSerializer, rootContexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Routes);\r\n    private setupNavigations;\r\n    private getTransition;\r\n    private setTransition;\r\n    /**\r\n     * Sets up the location change listener and performs the initial navigation.\r\n     */\r\n    initialNavigation(): void;\r\n    /**\r\n     * Sets up the location change listener.\r\n     */\r\n    setUpLocationChangeListener(): void;\r\n    /** The current URL. */\r\n    get url(): string;\r\n    /** The current Navigation object if one exists */\r\n    getCurrentNavigation(): Navigation | null;\r\n    /**\r\n     * Resets the route configuration used for navigation and generating links.\r\n     *\r\n     * @param config The route array for the new configuration.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ```\r\n     * router.resetConfig([\r\n     *  { path: 'team/:id', component: TeamCmp, children: [\r\n     *    { path: 'simple', component: SimpleCmp },\r\n     *    { path: 'user/:name', component: UserCmp }\r\n     *  ]}\r\n     * ]);\r\n     * ```\r\n     */\r\n    resetConfig(config: Routes): void;\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n    /** Disposes of the router. */\r\n    dispose(): void;\r\n    /**\r\n     * Appends URL segments to the current URL tree to create a new URL tree.\r\n     *\r\n     * @param commands An array of URL fragments with which to construct the new URL tree.\r\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\r\n     * segments, followed by the parameters for each segment.\r\n     * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\r\n     * property of the options object, if supplied.\r\n     * @param navigationExtras Options that control the navigation strategy. This function\r\n     * only uses properties in `NavigationExtras` that would change the provided URL.\r\n     * @returns The new URL tree.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ```\r\n     * // create /team/33/user/11\r\n     * router.createUrlTree(['/team', 33, 'user', 11]);\r\n     *\r\n     * // create /team/33;expand=true/user/11\r\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\r\n     *\r\n     * // you can collapse static segments like this (this works only with the first passed-in value):\r\n     * router.createUrlTree(['/team/33/user', userId]);\r\n     *\r\n     * // If the first segment can contain slashes, and you do not want the router to split it,\r\n     * // you can do the following:\r\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\r\n     *\r\n     * // create /team/33/(user/11//right:chat)\r\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\r\n     *\r\n     * // remove the right secondary node\r\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\r\n     *\r\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\r\n     *\r\n     * // navigate to /team/33/user/11/details\r\n     * router.createUrlTree(['details'], {relativeTo: route});\r\n     *\r\n     * // navigate to /team/33/user/22\r\n     * router.createUrlTree(['../22'], {relativeTo: route});\r\n     *\r\n     * // navigate to /team/44/user/22\r\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\r\n     * ```\r\n     */\r\n    createUrlTree(commands: any[], navigationExtras?: NavigationExtras): UrlTree;\r\n    /**\r\n     * Navigates to a view using an absolute route path.\r\n     *\r\n     * @param url An absolute path for a defined route. The function does not apply any delta to the\r\n     *     current URL.\r\n     * @param extras An object containing properties that modify the navigation strategy.\r\n     * The function ignores any properties in the `NavigationExtras` that would change the\r\n     * provided URL.\r\n     *\r\n     * @returns A Promise that resolves to 'true' when navigation succeeds,\r\n     * to 'false' when navigation fails, or is rejected on error.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * The following calls request navigation to an absolute path.\r\n     *\r\n     * ```\r\n     * router.navigateByUrl(\"/team/33/user/11\");\r\n     *\r\n     * // Navigate without updating the URL\r\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\r\n     * ```\r\n     *\r\n     * @see [Routing and Navigation guide](guide/router)\r\n     *\r\n     */\r\n    navigateByUrl(url: string | UrlTree, extras?: NavigationExtras): Promise<boolean>;\r\n    /**\r\n     * Navigate based on the provided array of commands and a starting point.\r\n     * If no starting route is provided, the navigation is absolute.\r\n     *\r\n     * @param commands An array of URL fragments with which to construct the target URL.\r\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\r\n     * segments, followed by the parameters for each segment.\r\n     * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\r\n     * of the options object, if supplied.\r\n     * @param extras An options object that determines how the URL should be constructed or\r\n     *     interpreted.\r\n     *\r\n     * @returns A Promise that resolves to `true` when navigation succeeds, to `false` when navigation\r\n     *     fails,\r\n     * or is rejected on error.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * The following calls request navigation to a dynamic route path relative to the current URL.\r\n     *\r\n     * ```\r\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\r\n     *\r\n     * // Navigate without updating the URL, overriding the default behavior\r\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\r\n     * ```\r\n     *\r\n     * @see [Routing and Navigation guide](guide/router)\r\n     *\r\n     */\r\n    navigate(commands: any[], extras?: NavigationExtras): Promise<boolean>;\r\n    /** Serializes a `UrlTree` into a string */\r\n    serializeUrl(url: UrlTree): string;\r\n    /** Parses a string into a `UrlTree` */\r\n    parseUrl(url: string): UrlTree;\r\n    /** Returns whether the url is activated */\r\n    isActive(url: string | UrlTree, exact: boolean): boolean;\r\n    private removeEmptyProps;\r\n    private processNavigations;\r\n    private scheduleNavigation;\r\n    private setBrowserUrl;\r\n    private resetStateAndUrl;\r\n    private resetUrlToCurrentUrlTree;\r\n}\r\n\r\n/**\r\n * A [DI token](guide/glossary/#di-token) for the router service.\r\n *\r\n * @publicApi\r\n */\r\nexport declare const ROUTER_CONFIGURATION: InjectionToken<ExtraOptions>;\r\n\r\n/**\r\n * A [DI token](guide/glossary/#di-token) for the router initializer that\r\n * is called after the app is bootstrapped.\r\n *\r\n * @publicApi\r\n */\r\nexport declare const ROUTER_INITIALIZER: InjectionToken<(compRef: ComponentRef<any>) => void>;\r\n\r\n/**\r\n * @description\r\n *\r\n * Provides a way to customize when activated routes get reused.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class RouteReuseStrategy {\r\n    /** Determines if this route (and its subtree) should be detached to be reused later */\r\n    abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\r\n    /**\r\n     * Stores the detached route.\r\n     *\r\n     * Storing a `null` value should erase the previously stored value.\r\n     */\r\n    abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;\r\n    /** Determines if this route (and its subtree) should be reattached */\r\n    abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\r\n    /** Retrieves the previously stored route */\r\n    abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;\r\n    /** Determines if a route should be reused */\r\n    abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\r\n}\r\n\r\n/**\r\n * Base for events the router goes through, as opposed to events tied to a specific\r\n * route. Fired one time for any given navigation.\r\n *\r\n * The following code shows how a class subscribes to router events.\r\n *\r\n * ```ts\r\n * class MyService {\r\n *   constructor(public router: Router, logger: Logger) {\r\n *     router.events.pipe(\r\n *        filter((e: Event): e is RouterEvent => e instanceof RouterEvent)\r\n *     ).subscribe((e: RouterEvent) => {\r\n *       logger.log(e.id, e.url);\r\n *     });\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @see `Event`\r\n * @see [Router events summary](guide/router#router-events)\r\n * @publicApi\r\n */\r\nexport declare class RouterEvent {\r\n    /** A unique ID that the router assigns to every router navigation. */\r\n    id: number;\r\n    /** The URL that is the destination for this navigation. */\r\n    url: string;\r\n    constructor(\r\n    /** A unique ID that the router assigns to every router navigation. */\r\n    id: number, \r\n    /** The URL that is the destination for this navigation. */\r\n    url: string);\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * When applied to an element in a template, makes that element a link\r\n * that initiates navigation to a route. Navigation opens one or more routed components\r\n * in one or more `<router-outlet>` locations on the page.\r\n *\r\n * Given a route configuration `[{ path: 'user/:name', component: UserCmp }]`,\r\n * the following creates a static link to the route:\r\n * `<a routerLink=\"/user/bob\">link to user component</a>`\r\n *\r\n * You can use dynamic values to generate the link.\r\n * For a dynamic link, pass an array of path segments,\r\n * followed by the params for each segment.\r\n * For example, `['/team', teamId, 'user', userName, {details: true}]`\r\n * generates a link to `/team/11/user/bob;details=true`.\r\n *\r\n * Multiple static segments can be merged into one term and combined with dynamic segements.\r\n * For example, `['/team/11/user', userName, {details: true}]`\r\n *\r\n * The input that you provide to the link is treated as a delta to the current URL.\r\n * For instance, suppose the current URL is `/user/(box//aux:team)`.\r\n * The link `<a [routerLink]=\"['/user/jim']\">Jim</a>` creates the URL\r\n * `/user/(jim//aux:team)`.\r\n * See {@link Router#createUrlTree createUrlTree} for more information.\r\n *\r\n * @usageNotes\r\n *\r\n * You can use absolute or relative paths in a link, set query parameters,\r\n * control how parameters are handled, and keep a history of navigation states.\r\n *\r\n * ### Relative link paths\r\n *\r\n * The first segment name can be prepended with `/`, `./`, or `../`.\r\n * * If the first segment begins with `/`, the router looks up the route from the root of the\r\n *   app.\r\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router\r\n *   looks in the children of the current activated route.\r\n * * If the first segment begins with `../`, the router goes up one level in the route tree.\r\n *\r\n * ### Setting and handling query params and fragments\r\n *\r\n * The following link adds a query parameter and a fragment to the generated URL:\r\n *\r\n * ```\r\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\r\n *   link to user component\r\n * </a>\r\n * ```\r\n * By default, the directive constructs the new URL using the given query parameters.\r\n * The example generates the link: `/user/bob?debug=true#education`.\r\n *\r\n * You can instruct the directive to handle query parameters differently\r\n * by specifying the `queryParamsHandling` option in the link.\r\n * Allowed values are:\r\n *\r\n *  - `'merge'`: Merge the given `queryParams` into the current query params.\r\n *  - `'preserve'`: Preserve the current query params.\r\n *\r\n * For example:\r\n *\r\n * ```\r\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\r\n *   link to user component\r\n * </a>\r\n * ```\r\n *\r\n * See {@link NavigationExtras.queryParamsHandling NavigationExtras#queryParamsHandling}.\r\n *\r\n * ### Preserving navigation history\r\n *\r\n * You can provide a `state` value to be persisted to the browser's\r\n * [`History.state` property](https://developer.mozilla.org/en-US/docs/Web/API/History#Properties).\r\n * For example:\r\n *\r\n * ```\r\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\r\n *   link to user component\r\n * </a>\r\n * ```\r\n *\r\n * Use {@link Router.getCurrentNavigation() Router#getCurrentNavigation} to retrieve a saved\r\n * navigation-state value. For example, to capture the `tracingId` during the `NavigationStart`\r\n * event:\r\n *\r\n * ```\r\n * // Get NavigationStart events\r\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\r\n *   const navigation = router.getCurrentNavigation();\r\n *   tracingService.trace({id: navigation.extras.state.tracingId});\r\n * });\r\n * ```\r\n *\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RouterLink implements OnChanges {\r\n    private router;\r\n    private route;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#queryParams NavigationExtras#queryParams}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    queryParams: {\r\n        [k: string]: any;\r\n    };\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#fragment NavigationExtras#fragment}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    fragment: string;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#queryParamsHandling NavigationExtras#queryParamsHandling}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    queryParamsHandling: QueryParamsHandling;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#preserveFragment NavigationExtras#preserveFragment}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    preserveFragment: boolean;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#skipLocationChange NavigationExtras#skipLocationChange}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    skipLocationChange: boolean;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#replaceUrl NavigationExtras#replaceUrl}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    replaceUrl: boolean;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#state NavigationExtras#state}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    state?: {\r\n        [k: string]: any;\r\n    };\r\n    private commands;\r\n    private preserve;\r\n    constructor(router: Router, route: ActivatedRoute, tabIndex: string, renderer: Renderer2, el: ElementRef);\r\n    /** @nodoc */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /**\r\n     * Commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\r\n     *   - **array**: commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\r\n     *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\r\n     *   - **null|undefined**: shorthand for an empty array of commands, i.e. `[]`\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    set routerLink(commands: any[] | string | null | undefined);\r\n    /**\r\n     * @deprecated As of Angular v4.0 use `queryParamsHandling` instead.\r\n     */\r\n    set preserveQueryParams(value: boolean);\r\n    /** @nodoc */\r\n    onClick(): boolean;\r\n    get urlTree(): UrlTree;\r\n}\r\n\r\n/**\r\n *\r\n * @description\r\n *\r\n * Tracks whether the linked route of an element is currently active, and allows you\r\n * to specify one or more CSS classes to add to the element when the linked route\r\n * is active.\r\n *\r\n * Use this directive to create a visual distinction for elements associated with an active route.\r\n * For example, the following code highlights the word \"Bob\" when the the router\r\n * activates the associated route:\r\n *\r\n * ```\r\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\r\n * ```\r\n *\r\n * Whenever the URL is either '/user' or '/user/bob', the \"active-link\" class is\r\n * added to the anchor tag. If the URL changes, the class is removed.\r\n *\r\n * You can set more than one class using a space-separated string or an array.\r\n * For example:\r\n *\r\n * ```\r\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\r\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\r\n * ```\r\n *\r\n * To add the classes only when the URL matches the link exactly, add the option `exact: true`:\r\n *\r\n * ```\r\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\r\n * true}\">Bob</a>\r\n * ```\r\n *\r\n * To directly check the `isActive` status of the link, assign the `RouterLinkActive`\r\n * instance to a template variable.\r\n * For example, the following checks the status without assigning any CSS classes:\r\n *\r\n * ```\r\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\r\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\r\n * </a>\r\n * ```\r\n *\r\n * You can apply the `RouterLinkActive` directive to an ancestor of linked elements.\r\n * For example, the following sets the active-link class on the `<div>`  parent tag\r\n * when the URL is either '/user/jim' or '/user/bob'.\r\n *\r\n * ```\r\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\r\n *   <a routerLink=\"/user/jim\">Jim</a>\r\n *   <a routerLink=\"/user/bob\">Bob</a>\r\n * </div>\r\n * ```\r\n *\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit {\r\n    private router;\r\n    private element;\r\n    private renderer;\r\n    private readonly cdr;\r\n    private link?;\r\n    private linkWithHref?;\r\n    links: QueryList<RouterLink>;\r\n    linksWithHrefs: QueryList<RouterLinkWithHref>;\r\n    private classes;\r\n    private routerEventsSubscription;\r\n    private linkInputChangesSubscription?;\r\n    readonly isActive: boolean;\r\n    routerLinkActiveOptions: {\r\n        exact: boolean;\r\n    };\r\n    constructor(router: Router, element: ElementRef, renderer: Renderer2, cdr: ChangeDetectorRef, link?: RouterLink | undefined, linkWithHref?: RouterLinkWithHref | undefined);\r\n    /** @nodoc */\r\n    ngAfterContentInit(): void;\r\n    private subscribeToEachLinkOnChanges;\r\n    set routerLinkActive(data: string[] | string);\r\n    /** @nodoc */\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n    private update;\r\n    private isLinkActive;\r\n    private hasActiveLinks;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Lets you link to specific routes in your app.\r\n *\r\n * See `RouterLink` for more information.\r\n *\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RouterLinkWithHref implements OnChanges, OnDestroy {\r\n    private router;\r\n    private route;\r\n    private locationStrategy;\r\n    target: string;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#queryParams NavigationExtras#queryParams}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    queryParams: {\r\n        [k: string]: any;\r\n    };\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#fragment NavigationExtras#fragment}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    fragment: string;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#queryParamsHandling NavigationExtras#queryParamsHandling}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    queryParamsHandling: QueryParamsHandling;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#preserveFragment NavigationExtras#preserveFragment}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    preserveFragment: boolean;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#skipLocationChange NavigationExtras#skipLocationChange}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    skipLocationChange: boolean;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#replaceUrl NavigationExtras#replaceUrl}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    replaceUrl: boolean;\r\n    /**\r\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\r\n     * @see {@link NavigationExtras#state NavigationExtras#state}\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    state?: {\r\n        [k: string]: any;\r\n    };\r\n    private commands;\r\n    private subscription;\r\n    private preserve;\r\n    href: string;\r\n    constructor(router: Router, route: ActivatedRoute, locationStrategy: LocationStrategy);\r\n    /**\r\n     * Commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\r\n     *   - **array**: commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\r\n     *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\r\n     *   - **null|undefined**: shorthand for an empty array of commands, i.e. `[]`\r\n     * @see {@link Router#createUrlTree Router#createUrlTree}\r\n     */\r\n    set routerLink(commands: any[] | string | null | undefined);\r\n    /**\r\n     * @deprecated As of Angular v4.0 use `queryParamsHandling` instead.\r\n     */\r\n    set preserveQueryParams(value: boolean);\r\n    /** @nodoc */\r\n    ngOnChanges(changes: SimpleChanges): any;\r\n    /** @nodoc */\r\n    ngOnDestroy(): any;\r\n    /** @nodoc */\r\n    onClick(button: number, ctrlKey: boolean, metaKey: boolean, shiftKey: boolean): boolean;\r\n    private updateTargetUrlAndHref;\r\n    get urlTree(): UrlTree;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Adds directives and providers for in-app navigation among views defined in an application.\r\n * Use the Angular `Router` service to declaratively specify application states and manage state\r\n * transitions.\r\n *\r\n * You can import this NgModule multiple times, once for each lazy-loaded bundle.\r\n * However, only one `Router` service can be active.\r\n * To ensure this, there are two ways to register routes when importing this module:\r\n *\r\n * * The `forRoot()` method creates an `NgModule` that contains all the directives, the given\r\n * routes, and the `Router` service itself.\r\n * * The `forChild()` method creates an `NgModule` that contains all the directives and the given\r\n * routes, but does not include the `Router` service.\r\n *\r\n * @see [Routing and Navigation guide](guide/router) for an\r\n * overview of how the `Router` service should be used.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RouterModule {\r\n    constructor(guard: any, router: Router);\r\n    /**\r\n     * Creates and configures a module with all the router providers and directives.\r\n     * Optionally sets up an application listener to perform an initial navigation.\r\n     *\r\n     * When registering the NgModule at the root, import as follows:\r\n     *\r\n     * ```\r\n     * @NgModule({\r\n     *   imports: [RouterModule.forRoot(ROUTES)]\r\n     * })\r\n     * class MyNgModule {}\r\n     * ```\r\n     *\r\n     * @param routes An array of `Route` objects that define the navigation paths for the application.\r\n     * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\r\n     * @return The new `NgModule`.\r\n     *\r\n     */\r\n    static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders<RouterModule>;\r\n    /**\r\n     * Creates a module with all the router directives and a provider registering routes,\r\n     * without creating a new Router service.\r\n     * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:\r\n     *\r\n     * ```\r\n     * @NgModule({\r\n     *   imports: [RouterModule.forChild(ROUTES)]\r\n     * })\r\n     * class MyNgModule {}\r\n     * ```\r\n     *\r\n     * @param routes An array of `Route` objects that define the navigation paths for the submodule.\r\n     * @return The new NgModule.\r\n     *\r\n     */\r\n    static forChild(routes: Routes): ModuleWithProviders<RouterModule>;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\r\n *\r\n * Each outlet can have a unique name, determined by the optional `name` attribute.\r\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\r\n *\r\n * ```\r\n * <router-outlet></router-outlet>\r\n * <router-outlet name='left'></router-outlet>\r\n * <router-outlet name='right'></router-outlet>\r\n * ```\r\n *\r\n * Named outlets can be the targets of secondary routes.\r\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\r\n *\r\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\r\n *\r\n * Using named outlets and secondary routes, you can target multiple outlets in\r\n * the same `RouterLink` directive.\r\n *\r\n * The router keeps track of separate branches in a navigation tree for each named outlet and\r\n * generates a representation of that tree in the URL.\r\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\r\n * routes at the same time:\r\n *\r\n * `http://base-path/primary-route-path(outlet-name:route-path)`\r\n *\r\n * A router outlet emits an activate event when a new component is instantiated,\r\n * and a deactivate event when a component is destroyed.\r\n *\r\n * ```\r\n * <router-outlet\r\n *   (activate)='onActivate($event)'\r\n *   (deactivate)='onDeactivate($event)'></router-outlet>\r\n * ```\r\n *\r\n * @see [Routing tutorial](guide/router-tutorial-toh#named-outlets \"Example of a named\r\n * outlet and secondary route configuration\").\r\n * @see `RouterLink`\r\n * @see `Route`\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RouterOutlet implements OnDestroy, OnInit {\r\n    private parentContexts;\r\n    private location;\r\n    private resolver;\r\n    private changeDetector;\r\n    private activated;\r\n    private _activatedRoute;\r\n    private name;\r\n    activateEvents: EventEmitter<any>;\r\n    deactivateEvents: EventEmitter<any>;\r\n    constructor(parentContexts: ChildrenOutletContexts, location: ViewContainerRef, resolver: ComponentFactoryResolver, name: string, changeDetector: ChangeDetectorRef);\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n    /** @nodoc */\r\n    ngOnInit(): void;\r\n    get isActivated(): boolean;\r\n    get component(): Object;\r\n    get activatedRoute(): ActivatedRoute;\r\n    get activatedRouteData(): Data;\r\n    /**\r\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\r\n     */\r\n    detach(): ComponentRef<any>;\r\n    /**\r\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\r\n     */\r\n    attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute): void;\r\n    deactivate(): void;\r\n    activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver | null): void;\r\n}\r\n\r\n/**\r\n * The preloader optimistically loads all router configurations to\r\n * make navigations into lazily-loaded sections of the application faster.\r\n *\r\n * The preloader runs in the background. When the router bootstraps, the preloader\r\n * starts listening to all navigation events. After every such event, the preloader\r\n * will check if any configurations can be loaded lazily.\r\n *\r\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RouterPreloader implements OnDestroy {\r\n    private router;\r\n    private injector;\r\n    private preloadingStrategy;\r\n    private loader;\r\n    private subscription?;\r\n    constructor(router: Router, moduleLoader: NgModuleFactoryLoader, compiler: Compiler, injector: Injector, preloadingStrategy: PreloadingStrategy);\r\n    setUpPreloading(): void;\r\n    preload(): Observable<any>;\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n    private processRoutes;\r\n    private preloadConfig;\r\n}\r\n\r\n/**\r\n * Represents the state of the router as a tree of activated routes.\r\n *\r\n * @usageNotes\r\n *\r\n * Every node in the route tree is an `ActivatedRoute` instance\r\n * that knows about the \"consumed\" URL segments, the extracted parameters,\r\n * and the resolved data.\r\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\r\n *\r\n * The following fragment shows how a component gets the root node\r\n * of the current state to establish its own route tree:\r\n *\r\n * ```\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const state: RouterState = router.routerState;\r\n *     const root: ActivatedRoute = state.root;\r\n *     const child = root.firstChild;\r\n *     const id: Observable<string> = child.params.map(p => p.id);\r\n *     //...\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @see `ActivatedRoute`\r\n * @see [Getting route information](guide/router#getting-route-information)\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RouterState extends ɵangular_packages_router_router_m<ActivatedRoute> {\r\n    /** The current snapshot of the router state */\r\n    snapshot: RouterStateSnapshot;\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Represents the state of the router at a moment in time.\r\n *\r\n * This is a tree of activated route snapshots. Every node in this tree knows about\r\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\r\n *\r\n * The following example shows how a component is initialized with information\r\n * from the snapshot of the root node's state at the time of creation.\r\n *\r\n * ```\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const state: RouterState = router.routerState;\r\n *     const snapshot: RouterStateSnapshot = state.snapshot;\r\n *     const root: ActivatedRouteSnapshot = snapshot.root;\r\n *     const child = root.firstChild;\r\n *     const id: Observable<string> = child.params.map(p => p.id);\r\n *     //...\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RouterStateSnapshot extends ɵangular_packages_router_router_m<ActivatedRouteSnapshot> {\r\n    /** The url from which this snapshot was created */\r\n    url: string;\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * The [DI token](guide/glossary/#di-token) for a router configuration.\r\n * @see `ROUTES`\r\n * @publicApi\r\n */\r\nexport declare const ROUTES: InjectionToken<Route[][]>;\r\n\r\n/**\r\n * Represents a route configuration for the Router service.\r\n * An array of `Route` objects, used in `Router.config` and for nested route configurations\r\n * in `Route.children`.\r\n *\r\n * @see `Route`\r\n * @see `Router`\r\n * @see [Router configuration guide](guide/router#configuration)\r\n * @publicApi\r\n */\r\nexport declare type Routes = Route[];\r\n\r\n/**\r\n * An event triggered when routes are recognized.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class RoutesRecognized extends RouterEvent {\r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string;\r\n    /** @docsNotRequired */\r\n    state: RouterStateSnapshot;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id: number, \r\n    /** @docsNotRequired */\r\n    url: string, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects: string, \r\n    /** @docsNotRequired */\r\n    state: RouterStateSnapshot);\r\n    /** @docsNotRequired */\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n *\r\n * A policy for when to run guards and resolvers on a route.\r\n *\r\n * @see [Route.runGuardsAndResolvers](api/router/Route#runGuardsAndResolvers)\r\n * @publicApi\r\n */\r\nexport declare type RunGuardsAndResolvers = 'pathParamsChange' | 'pathParamsOrQueryParamsChange' | 'paramsChange' | 'paramsOrQueryParamsChange' | 'always' | ((from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot) => boolean);\r\n\r\n/**\r\n * An event triggered by scrolling.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class Scroll {\r\n    /** @docsNotRequired */\r\n    readonly routerEvent: NavigationEnd;\r\n    /** @docsNotRequired */\r\n    readonly position: [number, number] | null;\r\n    /** @docsNotRequired */\r\n    readonly anchor: string | null;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    routerEvent: NavigationEnd, \r\n    /** @docsNotRequired */\r\n    position: [number, number] | null, \r\n    /** @docsNotRequired */\r\n    anchor: string | null);\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Provides a way to migrate AngularJS applications to Angular.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class UrlHandlingStrategy {\r\n    /**\r\n     * Tells the router if this URL should be processed.\r\n     *\r\n     * When it returns true, the router will execute the regular navigation.\r\n     * When it returns false, the router will set the router state to an empty state.\r\n     * As a result, all the active components will be destroyed.\r\n     *\r\n     */\r\n    abstract shouldProcessUrl(url: UrlTree): boolean;\r\n    /**\r\n     * Extracts the part of the URL that should be handled by the router.\r\n     * The rest of the URL will remain untouched.\r\n     */\r\n    abstract extract(url: UrlTree): UrlTree;\r\n    /**\r\n     * Merges the URL fragment with the rest of the URL.\r\n     */\r\n    abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;\r\n}\r\n\r\n/**\r\n * A function for matching a route against URLs. Implement a custom URL matcher\r\n * for `Route.matcher` when a combination of `path` and `pathMatch`\r\n * is not expressive enough. Cannot be used together with `path` and `pathMatch`.\r\n *\r\n * The function takes the following arguments and returns a `UrlMatchResult` object.\r\n * * *segments* : An array of URL segments.\r\n * * *group* : A segment group.\r\n * * *route* : The route to match against.\r\n *\r\n * The following example implementation matches HTML files.\r\n *\r\n * ```\r\n * export function htmlFiles(url: UrlSegment[]) {\r\n *   return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\r\n * }\r\n *\r\n * export const routes = [{ matcher: htmlFiles, component: AnyComponent }];\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) => UrlMatchResult | null;\r\n\r\n/**\r\n * Represents the result of matching URLs with a custom matching function.\r\n *\r\n * * `consumed` is an array of the consumed URL segments.\r\n * * `posParams` is a map of positional parameters.\r\n *\r\n * @see `UrlMatcher()`\r\n * @publicApi\r\n */\r\nexport declare type UrlMatchResult = {\r\n    consumed: UrlSegment[];\r\n    posParams?: {\r\n        [name: string]: UrlSegment;\r\n    };\r\n};\r\n\r\n/**\r\n * @description\r\n *\r\n * Represents a single URL segment.\r\n *\r\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\r\n * parameters associated with the segment.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\r\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\r\n *     const s: UrlSegment[] = g.segments;\r\n *     s[0].path; // returns 'team'\r\n *     s[0].parameters; // returns {id: 33}\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare class UrlSegment {\r\n    /** The path part of a URL segment */\r\n    path: string;\r\n    /** The matrix parameters associated with a segment */\r\n    parameters: {\r\n        [name: string]: string;\r\n    };\r\n    constructor(\r\n    /** The path part of a URL segment */\r\n    path: string, \r\n    /** The matrix parameters associated with a segment */\r\n    parameters: {\r\n        [name: string]: string;\r\n    });\r\n    get parameterMap(): ParamMap;\r\n    /** @docsNotRequired */\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Represents the parsed URL segment group.\r\n *\r\n * See `UrlTree` for more information.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class UrlSegmentGroup {\r\n    /** The URL segments of this group. See `UrlSegment` for more information */\r\n    segments: UrlSegment[];\r\n    /** The list of children of this group */\r\n    children: {\r\n        [key: string]: UrlSegmentGroup;\r\n    };\r\n    /** The parent node in the url tree */\r\n    parent: UrlSegmentGroup | null;\r\n    constructor(\r\n    /** The URL segments of this group. See `UrlSegment` for more information */\r\n    segments: UrlSegment[], \r\n    /** The list of children of this group */\r\n    children: {\r\n        [key: string]: UrlSegmentGroup;\r\n    });\r\n    /** Whether the segment has child segments */\r\n    hasChildren(): boolean;\r\n    /** Number of child segments */\r\n    get numberOfChildren(): number;\r\n    /** @docsNotRequired */\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Serializes and deserializes a URL string into a URL tree.\r\n *\r\n * The url serialization strategy is customizable. You can\r\n * make all URLs case insensitive by providing a custom UrlSerializer.\r\n *\r\n * See `DefaultUrlSerializer` for an example of a URL serializer.\r\n *\r\n * @publicApi\r\n */\r\nexport declare abstract class UrlSerializer {\r\n    /** Parse a url into a `UrlTree` */\r\n    abstract parse(url: string): UrlTree;\r\n    /** Converts a `UrlTree` into a url */\r\n    abstract serialize(tree: UrlTree): string;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Represents the parsed URL.\r\n *\r\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\r\n * serialized tree.\r\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const tree: UrlTree =\r\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\r\n *     const f = tree.fragment; // return 'fragment'\r\n *     const q = tree.queryParams; // returns {debug: 'true'}\r\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\r\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\r\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\r\n *     g.children['support'].segments; // return 1 segment 'help'\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare class UrlTree {\r\n    /** The root segment group of the URL tree */\r\n    root: UrlSegmentGroup;\r\n    /** The query params of the URL */\r\n    queryParams: Params;\r\n    /** The fragment of the URL */\r\n    fragment: string | null;\r\n    get queryParamMap(): ParamMap;\r\n    /** @docsNotRequired */\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport declare const VERSION: Version;\r\n\r\n/**\r\n * @docsNotRequired\r\n */\r\nexport declare const ɵangular_packages_router_router_a: InjectionToken<void>;\r\n\r\nexport declare function ɵangular_packages_router_router_b(): NgProbeToken;\r\n\r\nexport declare function ɵangular_packages_router_router_c(router: Router, viewportScroller: ViewportScroller, config: ExtraOptions): ɵangular_packages_router_router_o;\r\n\r\nexport declare function ɵangular_packages_router_router_d(platformLocationStrategy: PlatformLocation, baseHref: string, options?: ExtraOptions): HashLocationStrategy | PathLocationStrategy;\r\n\r\nexport declare function ɵangular_packages_router_router_e(router: Router): any;\r\n\r\nexport declare function ɵangular_packages_router_router_f(urlSerializer: UrlSerializer, contexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Route[][], opts?: ExtraOptions, urlHandlingStrategy?: UrlHandlingStrategy, routeReuseStrategy?: RouteReuseStrategy): Router;\r\n\r\nexport declare function ɵangular_packages_router_router_g(router: Router): ActivatedRoute;\r\n\r\n/**\r\n * Router initialization requires two steps:\r\n *\r\n * First, we start the navigation in a `APP_INITIALIZER` to block the bootstrap if\r\n * a resolver or a guard executes asynchronously.\r\n *\r\n * Next, we actually run activation in a `BOOTSTRAP_LISTENER`, using the\r\n * `afterPreactivation` hook provided by the router.\r\n * The router navigation starts, reaches the point when preactivation is done, and then\r\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\r\n */\r\nexport declare class ɵangular_packages_router_router_h {\r\n    private injector;\r\n    private initNavigation;\r\n    private resultOfPreactivationDone;\r\n    constructor(injector: Injector);\r\n    appInitializer(): Promise<any>;\r\n    bootstrapListener(bootstrappedComponentRef: ComponentRef<any>): void;\r\n    private isLegacyEnabled;\r\n    private isLegacyDisabled;\r\n}\r\n\r\nexport declare function ɵangular_packages_router_router_i(r: ɵangular_packages_router_router_h): () => Promise<any>;\r\n\r\nexport declare function ɵangular_packages_router_router_j(r: ɵangular_packages_router_router_h): (bootstrappedComponentRef: ComponentRef<any>) => void;\r\n\r\nexport declare function ɵangular_packages_router_router_k(): (typeof ɵangular_packages_router_router_h | {\r\n    provide: InjectionToken<(() => void)[]>;\r\n    multi: boolean;\r\n    useFactory: typeof ɵangular_packages_router_router_i;\r\n    deps: (typeof ɵangular_packages_router_router_h)[];\r\n    useExisting?: undefined;\r\n} | {\r\n    provide: InjectionToken<(compRef: ComponentRef<any>) => void>;\r\n    useFactory: typeof ɵangular_packages_router_router_j;\r\n    deps: (typeof ɵangular_packages_router_router_h)[];\r\n    multi?: undefined;\r\n    useExisting?: undefined;\r\n} | {\r\n    provide: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;\r\n    multi: boolean;\r\n    useExisting: InjectionToken<(compRef: ComponentRef<any>) => void>;\r\n    useFactory?: undefined;\r\n    deps?: undefined;\r\n})[];\r\n\r\n\r\nexport declare class ɵangular_packages_router_router_m<T> {\r\n    constructor(root: ɵangular_packages_router_router_n<T>);\r\n    get root(): T;\r\n}\r\n\r\nexport declare class ɵangular_packages_router_router_n<T> {\r\n    value: T;\r\n    children: ɵangular_packages_router_router_n<T>[];\r\n    constructor(value: T, children: ɵangular_packages_router_router_n<T>[]);\r\n    toString(): string;\r\n}\r\n\r\nexport declare class ɵangular_packages_router_router_o implements OnDestroy {\r\n    private router;\r\n    /** @docsNotRequired */ readonly viewportScroller: ViewportScroller;\r\n    private options;\r\n    private routerEventsSubscription;\r\n    private scrollEventsSubscription;\r\n    private lastId;\r\n    private lastSource;\r\n    private restoredId;\r\n    private store;\r\n    constructor(router: Router, \r\n    /** @docsNotRequired */ viewportScroller: ViewportScroller, options?: {\r\n        scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\r\n        anchorScrolling?: 'disabled' | 'enabled';\r\n    });\r\n    init(): void;\r\n    private createScrollEvents;\r\n    private consumeScrollEvents;\r\n    private scheduleScrollEvent;\r\n    /** @nodoc */\r\n    ngOnDestroy(): void;\r\n}\r\n\r\n\r\n/**\r\n * This component is used internally within the router to be a placeholder when an empty\r\n * router-outlet is needed. For example, with a config such as:\r\n *\r\n * `{path: 'parent', outlet: 'nav', children: [...]}`\r\n *\r\n * In order to render, there needs to be a component on this config, which will default\r\n * to this `EmptyOutletComponent`.\r\n */\r\ndeclare class ɵEmptyOutletComponent {\r\n}\r\nexport { ɵEmptyOutletComponent }\r\nexport { ɵEmptyOutletComponent as ɵangular_packages_router_router_l }\r\n\r\n/**\r\n * Flattens single-level nested arrays.\r\n */\r\nexport declare function ɵflatten<T>(arr: T[][]): T[];\r\n\r\nexport declare const ɵROUTER_PROVIDERS: Provider[];\r\n\r\nexport { }\r\n"]}