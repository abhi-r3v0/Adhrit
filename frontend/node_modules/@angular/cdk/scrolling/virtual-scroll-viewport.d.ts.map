{"version":3,"file":"virtual-scroll-viewport.d.ts","sources":["virtual-scroll-viewport.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ListRange } from '@angular/cdk/collections';\nimport { ChangeDetectorRef, ElementRef, NgZone, OnDestroy, OnInit } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { ScrollDispatcher } from './scroll-dispatcher';\nimport { CdkScrollable } from './scrollable';\nimport { VirtualScrollStrategy } from './virtual-scroll-strategy';\nimport { ViewportRuler } from './viewport-ruler';\nimport { CdkVirtualScrollRepeater } from './virtual-scroll-repeater';\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\nexport declare class CdkVirtualScrollViewport extends CdkScrollable implements OnInit, OnDestroy {\n    elementRef: ElementRef<HTMLElement>;\n    private _changeDetectorRef;\n    private _scrollStrategy;\n    /** Emits when the viewport is detached from a CdkVirtualForOf. */\n    private _detachedSubject;\n    /** Emits when the rendered range changes. */\n    private _renderedRangeSubject;\n    /** The direction the viewport scrolls. */\n    get orientation(): 'horizontal' | 'vertical';\n    set orientation(orientation: 'horizontal' | 'vertical');\n    private _orientation;\n    /** Emits when the index of the first element visible in the viewport changes. */\n    scrolledIndexChange: Observable<number>;\n    /** The element that wraps the rendered content. */\n    _contentWrapper: ElementRef<HTMLElement>;\n    /** A stream that emits whenever the rendered range changes. */\n    renderedRangeStream: Observable<ListRange>;\n    /**\n     * The total size of all content (in pixels), including content that is not currently rendered.\n     */\n    private _totalContentSize;\n    /** A string representing the `style.width` property value to be used for the spacer element. */\n    _totalContentWidth: string;\n    /** A string representing the `style.height` property value to be used for the spacer element. */\n    _totalContentHeight: string;\n    /**\n     * The CSS transform applied to the rendered subset of items so that they appear within the bounds\n     * of the visible viewport.\n     */\n    private _renderedContentTransform;\n    /** The currently rendered range of indices. */\n    private _renderedRange;\n    /** The length of the data bound to this viewport (in number of items). */\n    private _dataLength;\n    /** The size of the viewport (in pixels). */\n    private _viewportSize;\n    /** the currently attached CdkVirtualScrollRepeater. */\n    private _forOf;\n    /** The last rendered content offset that was set. */\n    private _renderedContentOffset;\n    /**\n     * Whether the last rendered content offset was to the end of the content (and therefore needs to\n     * be rewritten as an offset to the start of the content).\n     */\n    private _renderedContentOffsetNeedsRewrite;\n    /** Whether there is a pending change detection cycle. */\n    private _isChangeDetectionPending;\n    /** A list of functions to run after the next change detection cycle. */\n    private _runAfterChangeDetection;\n    /** Subscription to changes in the viewport size. */\n    private _viewportChanges;\n    constructor(elementRef: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, ngZone: NgZone, _scrollStrategy: VirtualScrollStrategy, dir: Directionality, scrollDispatcher: ScrollDispatcher, \n    /**\n     * @deprecated `viewportRuler` parameter to become required.\n     * @breaking-change 11.0.0\n     */\n    viewportRuler?: ViewportRuler);\n    ngOnInit(): void;\n    ngOnDestroy(): void;\n    /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\n    attach(forOf: CdkVirtualScrollRepeater<any>): void;\n    /** Detaches the current `CdkVirtualForOf`. */\n    detach(): void;\n    /** Gets the length of the data bound to this viewport (in number of items). */\n    getDataLength(): number;\n    /** Gets the size of the viewport (in pixels). */\n    getViewportSize(): number;\n    /** Get the current rendered range of items. */\n    getRenderedRange(): ListRange;\n    /**\n     * Sets the total size of all content (in pixels), including content that is not currently\n     * rendered.\n     */\n    setTotalContentSize(size: number): void;\n    /** Sets the currently rendered range of indices. */\n    setRenderedRange(range: ListRange): void;\n    /**\n     * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n     */\n    getOffsetToRenderedContentStart(): number | null;\n    /**\n     * Sets the offset from the start of the viewport to either the start or end of the rendered data\n     * (in pixels).\n     */\n    setRenderedContentOffset(offset: number, to?: 'to-start' | 'to-end'): void;\n    /**\n     * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n     * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n     * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n     * @param offset The offset to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToOffset(offset: number, behavior?: ScrollBehavior): void;\n    /**\n     * Scrolls to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToIndex(index: number, behavior?: ScrollBehavior): void;\n    /**\n     * Gets the current scroll offset from the start of the viewport (in pixels).\n     * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n     *     in horizontal mode.\n     */\n    measureScrollOffset(from?: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number;\n    /** Measure the combined size of all of the rendered items. */\n    measureRenderedContentSize(): number;\n    /**\n     * Measure the total combined size of the given range. Throws if the range includes items that are\n     * not rendered.\n     */\n    measureRangeSize(range: ListRange): number;\n    /** Update the viewport dimensions and re-render. */\n    checkViewportSize(): void;\n    /** Measure the viewport size. */\n    private _measureViewportSize;\n    /** Queue up change detection to run. */\n    private _markChangeDetectionNeeded;\n    /** Run change detection. */\n    private _doChangeDetection;\n    /** Calculates the `style.width` and `style.height` for the spacer element. */\n    private _calculateSpacerSize;\n}\n"]}