{"version":3,"file":"observe-content.d.ts","sources":["observe-content.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;;;AACA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { AfterContentInit, ElementRef, EventEmitter, NgZone, OnDestroy } from '@angular/core';\nimport { Observable } from 'rxjs';\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\nexport declare class MutationObserverFactory {\n    create(callback: MutationCallback): MutationObserver | null;\n}\n/** An injectable service that allows watching elements for changes to their content. */\nexport declare class ContentObserver implements OnDestroy {\n    private _mutationObserverFactory;\n    /** Keeps track of the existing MutationObservers so they can be reused. */\n    private _observedElements;\n    constructor(_mutationObserverFactory: MutationObserverFactory);\n    ngOnDestroy(): void;\n    /**\n     * Observe content changes on an element.\n     * @param element The element to observe for content changes.\n     */\n    observe(element: Element): Observable<MutationRecord[]>;\n    /**\n     * Observe content changes on an element.\n     * @param element The element to observe for content changes.\n     */\n    observe(element: ElementRef<Element>): Observable<MutationRecord[]>;\n    /**\n     * Observes the given element by using the existing MutationObserver if available, or creating a\n     * new one if not.\n     */\n    private _observeElement;\n    /**\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n     * observing this element.\n     */\n    private _unobserveElement;\n    /** Clean up the underlying MutationObserver for the specified element. */\n    private _cleanupObserver;\n}\n/**\n * Directive that triggers a callback whenever the content of\n * its associated element has changed.\n */\nexport declare class CdkObserveContent implements AfterContentInit, OnDestroy {\n    private _contentObserver;\n    private _elementRef;\n    private _ngZone;\n    /** Event emitted for each change in the element's content. */\n    event: EventEmitter<MutationRecord[]>;\n    /**\n     * Whether observing content is disabled. This option can be used\n     * to disconnect the underlying MutationObserver until it is needed.\n     */\n    get disabled(): any;\n    set disabled(value: any);\n    private _disabled;\n    /** Debounce interval for emitting the changes. */\n    get debounce(): number;\n    set debounce(value: number);\n    private _debounce;\n    private _currentSubscription;\n    constructor(_contentObserver: ContentObserver, _elementRef: ElementRef<HTMLElement>, _ngZone: NgZone);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    private _subscribe;\n    private _unsubscribe;\n    static ngAcceptInputType_disabled: BooleanInput;\n    static ngAcceptInputType_debounce: BooleanInput;\n}\nexport declare class ObserversModule {\n}\n"]}